"use strict";(self.webpackChunkCRIS=self.webpackChunkCRIS||[]).push([[3781],{14658:(fe,se,g)=>{function z(){return new Float32Array(3)}function Y(k,c,T){const f=new Float32Array(3);return f[0]=k,f[1]=c,f[2]=T,f}function J(){return z()}function X(){return Y(1,1,1)}function ee(){return Y(1,0,0)}function q(){return Y(0,1,0)}function I(){return Y(0,0,1)}g.d(se,{c:()=>z,f:()=>Y});const Q=J(),L=X(),W=ee(),N=q(),Z=I();Object.freeze(Object.defineProperty({__proto__:null,ONES:L,UNIT_X:W,UNIT_Y:N,UNIT_Z:Z,ZEROS:Q,clone:function U(k){const c=new Float32Array(3);return c[0]=k[0],c[1]=k[1],c[2]=k[2],c},create:z,createView:function E(k,c){return new Float32Array(k,c,3)},fromValues:Y,ones:X,unitX:ee,unitY:q,unitZ:I,zeros:J},Symbol.toStringTag,{value:"Module"}))},50011:(fe,se,g)=>{g.d(se,{F:()=>k,M:()=>z});const z={Base64:0,Hex:1,String:2,Raw:3},U=8,Y=(1<<U)-1;function E(c,T){const f=(65535&c)+(65535&T);return(c>>16)+(T>>16)+(f>>16)<<16|65535&f}function Q(c,T,f,p,d,l){return E(function I(c,T){return c<<T|c>>>32-T}(E(E(T,c),E(p,l)),d),f)}function L(c,T,f,p,d,l,u){return Q(T&f|~T&p,c,T,d,l,u)}function W(c,T,f,p,d,l,u){return Q(T&p|f&~p,c,T,d,l,u)}function N(c,T,f,p,d,l,u){return Q(T^f^p,c,T,d,l,u)}function Z(c,T,f,p,d,l,u){return Q(f^(T|~p),c,T,d,l,u)}function k(c,T=z.Hex){const f=T||z.Base64,p=function H(c,T){c[T>>5]|=128<<T%32,c[14+(T+64>>>9<<4)]=T;let f=1732584193,p=-271733879,d=-1732584194,l=271733878;for(let u=0;u<c.length;u+=16){const C=f,_=p,O=d,K=l;f=L(f,p,d,l,c[u],7,-680876936),l=L(l,f,p,d,c[u+1],12,-389564586),d=L(d,l,f,p,c[u+2],17,606105819),p=L(p,d,l,f,c[u+3],22,-1044525330),f=L(f,p,d,l,c[u+4],7,-176418897),l=L(l,f,p,d,c[u+5],12,1200080426),d=L(d,l,f,p,c[u+6],17,-1473231341),p=L(p,d,l,f,c[u+7],22,-45705983),f=L(f,p,d,l,c[u+8],7,1770035416),l=L(l,f,p,d,c[u+9],12,-1958414417),d=L(d,l,f,p,c[u+10],17,-42063),p=L(p,d,l,f,c[u+11],22,-1990404162),f=L(f,p,d,l,c[u+12],7,1804603682),l=L(l,f,p,d,c[u+13],12,-40341101),d=L(d,l,f,p,c[u+14],17,-1502002290),p=L(p,d,l,f,c[u+15],22,1236535329),f=W(f,p,d,l,c[u+1],5,-165796510),l=W(l,f,p,d,c[u+6],9,-1069501632),d=W(d,l,f,p,c[u+11],14,643717713),p=W(p,d,l,f,c[u],20,-373897302),f=W(f,p,d,l,c[u+5],5,-701558691),l=W(l,f,p,d,c[u+10],9,38016083),d=W(d,l,f,p,c[u+15],14,-660478335),p=W(p,d,l,f,c[u+4],20,-405537848),f=W(f,p,d,l,c[u+9],5,568446438),l=W(l,f,p,d,c[u+14],9,-1019803690),d=W(d,l,f,p,c[u+3],14,-187363961),p=W(p,d,l,f,c[u+8],20,1163531501),f=W(f,p,d,l,c[u+13],5,-1444681467),l=W(l,f,p,d,c[u+2],9,-51403784),d=W(d,l,f,p,c[u+7],14,1735328473),p=W(p,d,l,f,c[u+12],20,-1926607734),f=N(f,p,d,l,c[u+5],4,-378558),l=N(l,f,p,d,c[u+8],11,-2022574463),d=N(d,l,f,p,c[u+11],16,1839030562),p=N(p,d,l,f,c[u+14],23,-35309556),f=N(f,p,d,l,c[u+1],4,-1530992060),l=N(l,f,p,d,c[u+4],11,1272893353),d=N(d,l,f,p,c[u+7],16,-155497632),p=N(p,d,l,f,c[u+10],23,-1094730640),f=N(f,p,d,l,c[u+13],4,681279174),l=N(l,f,p,d,c[u],11,-358537222),d=N(d,l,f,p,c[u+3],16,-722521979),p=N(p,d,l,f,c[u+6],23,76029189),f=N(f,p,d,l,c[u+9],4,-640364487),l=N(l,f,p,d,c[u+12],11,-421815835),d=N(d,l,f,p,c[u+15],16,530742520),p=N(p,d,l,f,c[u+2],23,-995338651),f=Z(f,p,d,l,c[u],6,-198630844),l=Z(l,f,p,d,c[u+7],10,1126891415),d=Z(d,l,f,p,c[u+14],15,-1416354905),p=Z(p,d,l,f,c[u+5],21,-57434055),f=Z(f,p,d,l,c[u+12],6,1700485571),l=Z(l,f,p,d,c[u+3],10,-1894986606),d=Z(d,l,f,p,c[u+10],15,-1051523),p=Z(p,d,l,f,c[u+1],21,-2054922799),f=Z(f,p,d,l,c[u+8],6,1873313359),l=Z(l,f,p,d,c[u+15],10,-30611744),d=Z(d,l,f,p,c[u+6],15,-1560198380),p=Z(p,d,l,f,c[u+13],21,1309151649),f=Z(f,p,d,l,c[u+4],6,-145523070),l=Z(l,f,p,d,c[u+11],10,-1120210379),d=Z(d,l,f,p,c[u+2],15,718787259),p=Z(p,d,l,f,c[u+9],21,-343485551),f=E(f,C),p=E(p,_),d=E(d,O),l=E(l,K)}return[f,p,d,l]}(function J(c){const T=[];for(let f=0,p=c.length*U;f<p;f+=U)T[f>>5]|=(c.charCodeAt(f/U)&Y)<<f%32;return T}(c),c.length*U);switch(f){case z.Raw:return p;case z.Hex:return function ee(c){const T="0123456789abcdef",f=[];for(let p=0,d=4*c.length;p<d;p++)f.push(T.charAt(c[p>>2]>>p%4*8+4&15)+T.charAt(c[p>>2]>>p%4*8&15));return f.join("")}(p);case z.String:return function X(c){const T=[];for(let f=0,p=32*c.length;f<p;f+=U)T.push(String.fromCharCode(c[f>>5]>>>f%32&Y));return T.join("")}(p);case z.Base64:return function q(c){const p=[];for(let d=0,l=4*c.length;d<l;d+=3){const u=(c[d>>2]>>d%4*8&255)<<16|(c[d+1>>2]>>(d+1)%4*8&255)<<8|c[d+2>>2]>>(d+2)%4*8&255;for(let C=0;C<4;C++)p.push(8*d+6*C>32*c.length?"=":"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(u>>6*(3-C)&63))}return p.join("")}(p)}}},65629:(fe,se,g)=>{g.d(se,{SR:()=>I,Ui:()=>q});var z=g(86810),U=g(65401),Y=g(32442),E=g(25748),J=g(91179),X=g(74618),ee=g(37053);function q(d){return Q(d,!0)}function I(d){return Q(d,!1)}function Q(d,l){if(null==d)return null;const u=d.spatialReference,C=(0,ee.C5)(u),_=(0,z.AK)(d)?d.toJSON():d;if(!C)return _;const O=(0,ee.sS)(u)?102100:4326,K=X.UZ[O].maxX,P=X.UZ[O].minX;if((0,J.wp)(_))return W(_,K,P);if((0,J.aW)(_))return _.points=_.points.map(R=>W(R,K,P)),_;if((0,J.YX)(_))return function L(d,l){if(!l)return d;const u=function N(d,l){const u=[],{ymin:C,ymax:_,xmin:O,xmax:K}=d,P=d.xmax-d.xmin,[R,D]=l.valid,{x:S,frameId:M}=Z(d.xmin,l),{x:A,frameId:V}=Z(d.xmax,l),B=S===A&&P>0;if(P>2*D){const j={xmin:O<K?S:A,ymin:C,xmax:D,ymax:_},he={xmin:R,ymin:C,xmax:O<K?A:S,ymax:_},G={xmin:0,ymin:C,xmax:D,ymax:_},Ce={xmin:R,ymin:C,xmax:0,ymax:_},ue=[],le=[];H(j,G)&&ue.push(M),H(j,Ce)&&le.push(M),H(he,G)&&ue.push(V),H(he,Ce)&&le.push(V);for(let re=M+1;re<V;re++)ue.push(re),le.push(re);u.push(new T(j,[M]),new T(he,[V]),new T(G,ue),new T(Ce,le))}else S>A||B?u.push(new T({xmin:S,ymin:C,xmax:D,ymax:_},[M]),new T({xmin:R,ymin:C,xmax:A,ymax:_},[V])):u.push(new T({xmin:S,ymin:C,xmax:A,ymax:_},[M]));return u}(d,l).map(C=>C.extent);return u.length<2?u[0]||d:u.length>2?(d.xmin=l.valid[0],d.xmax=l.valid[1],d):{rings:u.map(C=>[[C.xmin,C.ymin],[C.xmin,C.ymax],[C.xmax,C.ymax],[C.xmax,C.ymin],[C.xmin,C.ymin]])}}(_,C);if((0,J.oU)(_)||(0,J.l9)(_)){const R=(0,Y.$P)(f,_),D={xmin:R[0],ymin:R[1],xmax:R[2],ymax:R[3]},S=(0,X.XZ)(D.xmin,P)*(2*K),M=0===S?_:(0,X.Sy)(_,S);return D.xmin+=S,D.xmax+=S,D.xmax>K?c(M,K,l):D.xmin<P?c(M,P,l):M}return _}function W(d,l,u){if(Array.isArray(d)){const C=d[0];if(C>l){const _=(0,X.XZ)(C,l);d[0]=C+_*(-2*l)}else if(C<u){const _=(0,X.XZ)(C,u);d[0]=C+_*(-2*u)}}else{const C=d.x;if(C>l){const _=(0,X.XZ)(C,l);d.x+=_*(-2*l)}else if(C<u){const _=(0,X.XZ)(C,u);d.x+=_*(-2*u)}}return d}function Z(d,l){const[u,C]=l.valid,_=2*C;let O,K=0;return d>C?(O=Math.ceil(Math.abs(d-C)/_),d-=O*_,K=O):d<u&&(O=Math.ceil(Math.abs(d-u)/_),d+=O*_,K=-O),{x:d,frameId:K}}function H(d,l){const{xmin:u,ymin:C,xmax:_,ymax:O}=l;return k(d,u,C)&&k(d,u,O)&&k(d,_,O)&&k(d,_,C)}function k(d,l,u){return l>=d.xmin&&l<=d.xmax&&u>=d.ymin&&u<=d.ymax}function c(d,l,u=!0){const C=!(0,J.l9)(d);if(C&&(0,E.Zy)(d),u)return(new p).cut(d,l);const _=C?d.rings:d.paths,O=C?4:2,K=_.length,P=-2*l;for(let R=0;R<K;R++){const D=_[R];if(D&&D.length>=O){const S=[];for(const M of D)S.push([M[0]+P,M[1]]);_.push(S)}}return C?d.rings=_:d.paths=_,d}class T{constructor(l,u){this.extent=l,this.frameIds=u}}const f=(0,U.Ue)();class p{constructor(){this._linesIn=[],this._linesOut=[]}cut(l,u){let C;if(this._xCut=u,l.rings)this._closed=!0,C=l.rings,this._minPts=4;else{if(!l.paths)return null;this._closed=!1,C=l.paths,this._minPts=2}for(const O of C){if(!O||O.length<this._minPts)continue;let K=!0;for(const P of O)K?(this.moveTo(P),K=!1):this.lineTo(P);this._closed&&this.close()}this._pushLineIn(),this._pushLineOut(),C=[];for(const O of this._linesIn)O&&O.length>=this._minPts&&C.push(O);const _=-2*this._xCut;for(const O of this._linesOut)if(O&&O.length>=this._minPts){for(const K of O)K[0]+=_;C.push(O)}return this._closed?l.rings=C:l.paths=C,l}moveTo(l){this._pushLineIn(),this._pushLineOut(),this._prevSide=this._side(l[0]),this._moveTo(l[0],l[1],this._prevSide),this._prevPt=l,this._firstPt=l}lineTo(l){const u=this._side(l[0]);if(u*this._prevSide==-1){const C=this._intersect(this._prevPt,l);this._lineTo(this._xCut,C,0),this._prevSide=0,this._lineTo(l[0],l[1],u)}else this._lineTo(l[0],l[1],u);this._prevSide=u,this._prevPt=l}close(){const l=this._firstPt,u=this._prevPt;l[0]===u[0]&&l[1]===u[1]||this.lineTo(l),this._checkClosingPt(this._lineIn),this._checkClosingPt(this._lineOut)}_moveTo(l,u,C){this._closed?(this._lineIn.push([C<=0?l:this._xCut,u]),this._lineOut.push([C>=0?l:this._xCut,u])):(C<=0&&this._lineIn.push([l,u]),C>=0&&this._lineOut.push([l,u]))}_lineTo(l,u,C){this._closed?(this._addPolyVertex(this._lineIn,C<=0?l:this._xCut,u),this._addPolyVertex(this._lineOut,C>=0?l:this._xCut,u)):C<0?(0===this._prevSide&&this._pushLineOut(),this._lineIn.push([l,u])):C>0?(0===this._prevSide&&this._pushLineIn(),this._lineOut.push([l,u])):this._prevSide<0?(this._lineIn.push([l,u]),this._lineOut.push([l,u])):this._prevSide>0&&(this._lineOut.push([l,u]),this._lineIn.push([l,u]))}_addPolyVertex(l,u,C){const _=l.length;_>1&&l[_-1][0]===u&&l[_-2][0]===u?l[_-1][1]=C:l.push([u,C])}_checkClosingPt(l){const u=l.length;u>3&&l[0][0]===this._xCut&&l[u-2][0]===this._xCut&&l[1][0]===this._xCut&&(l[0][1]=l[u-2][1],l.pop())}_side(l){return l<this._xCut?-1:l>this._xCut?1:0}_intersect(l,u){return l[1]+(this._xCut-l[0])/(u[0]-l[0])*(u[1]-l[1])}_pushLineIn(){this._lineIn&&this._lineIn.length>=this._minPts&&this._linesIn.push(this._lineIn),this._lineIn=[]}_pushLineOut(){this._lineOut&&this._lineOut.length>=this._minPts&&this._linesOut.push(this._lineOut),this._lineOut=[]}}},43149:(fe,se,g)=>{g.d(se,{Z:()=>Q});var q,z=g(17626),U=g(86810),Y=g(58817),E=g(77712),X=(g(90912),g(76898)),ee=g(95778);let I=q=class extends U.wq{constructor(L){super(L),this.isAutoGenerated=!1,this.name=null,this.alias=null,this.onStatisticField=null,this.onStatisticExpression=null,this.statisticType=null}clone(){return new q({name:this.name,alias:this.alias,isAutoGenerated:this.isAutoGenerated,onStatisticExpression:(0,Y.d9)(this.onStatisticExpression),onStatisticField:this.onStatisticField,statisticType:this.statisticType})}};(0,z._)([(0,E.Cb)({type:Boolean,json:{write:!0}})],I.prototype,"isAutoGenerated",void 0),(0,z._)([(0,E.Cb)({type:String,json:{write:!0}})],I.prototype,"name",void 0),(0,z._)([(0,E.Cb)({type:String,json:{write:!0}})],I.prototype,"alias",void 0),(0,z._)([(0,E.Cb)({type:String,json:{write:!0}})],I.prototype,"onStatisticField",void 0),(0,z._)([(0,E.Cb)({type:ee.Z,json:{write:!0}})],I.prototype,"onStatisticExpression",void 0),(0,z._)([(0,E.Cb)({type:String,json:{write:!0}})],I.prototype,"statisticType",void 0),I=q=(0,z._)([(0,X.j)("esri.layers.support.AggregateField")],I);const Q=I},95778:(fe,se,g)=>{g.d(se,{Z:()=>Q});var z=g(17626),U=g(79608),Y=g(86810),E=g(77712),q=(g(90912),g(85931),g(8314),g(76898));let I=class extends((0,U.J)(Y.wq)){constructor(L){super(L),this.expression=null,this.title=null,this.returnType=null}};(0,z._)([(0,E.Cb)({type:String,json:{write:!0}})],I.prototype,"expression",void 0),(0,z._)([(0,E.Cb)({type:String,json:{write:!0}})],I.prototype,"title",void 0),(0,z._)([(0,E.Cb)({type:String,json:{write:!0}})],I.prototype,"returnType",void 0),I=(0,z._)([(0,q.j)("esri.layers.support.ExpressionInfo")],I);const Q=I},78209:(fe,se,g)=>{g.d(se,{Z:()=>Ct});var z=g(15861),U=g(17626),Y=g(83761),E=g(85931),J=g(986),X=g(8314),ee=g(61996),q=g(62208),I=g(10699),Q=g(32917),L=g(77712),N=(g(90912),g(76898)),Z=g(65234),H=g(65401),k=g(25748),c=g(91179),T=g(65629),f=g(37053),p=g(82959),d=g(35909),l=g(8080),u=g(39351),C=g(39406);const _=-1;class O{constructor(){this._dirties=[{vertexFrom:_,vertexCount:_,indexFrom:_,indexCount:_,allDirty:!1},{vertexFrom:_,vertexCount:_,indexFrom:_,indexCount:_,allDirty:!1},{vertexFrom:_,vertexCount:_,indexFrom:_,indexCount:_,allDirty:!1},{vertexFrom:_,vertexCount:_,indexFrom:_,indexCount:_,allDirty:!1},{vertexFrom:_,vertexCount:_,indexFrom:_,indexCount:_,allDirty:!1}]}hasDirty(){return this._dirties.some(e=>e.indexCount!==_||e.allDirty)}markAllClean(){for(const e of this._dirties)e.indexFrom=_,e.indexCount=_,e.vertexFrom=_,e.vertexCount=_,e.allDirty=!1}markAllDirty(){for(const e of this._dirties)e.allDirty=!0}forEach(e){for(let t=0;t<this._dirties.length;++t){const{indexCount:s,indexFrom:i,vertexCount:r,vertexFrom:n,allDirty:o}=this._dirties[t],h={};let m,v=!1;(o||n!==_&&r>0)&&(h.geometry={count:r,from:n,allDirty:o},v=!0),(o||i!==_&&s>0)&&(m={count:s,from:i,allDirty:o},v=!0),v&&e({indices:m,vertices:h},t)}}markDirtyIndices(e,t,s){const i=this._dirties[e],r=t,n=s;if(!i.allDirty)if(i.indexCount!==_){const o=Math.min(i.indexFrom,r),h=Math.max(i.indexFrom+i.indexCount,r+n)-o;i.indexFrom=o,i.indexCount=h}else i.indexFrom=r,i.indexCount=n}markDirtyVertices(e,t,s,i){const r=this._dirties[e],n=s,o=i;if(!r.allDirty)if(r.vertexCount!==_){const h=Math.min(r.vertexFrom,n),m=Math.max(r.vertexFrom+r.vertexCount,n+o)-h;r.vertexFrom=h,r.vertexCount=m}else r.vertexFrom=n,r.vertexCount=o}}class K{get largestRange(){return this._largestRange}constructor(e){this._largestRange=null,this._parent=e,this._updateLargestRange()}rangeCreated(e){(!this._largestRange||e.count>this._largestRange.count)&&(this._largestRange=e)}rangeResized(e,t){e===this._largestRange?e.count<t&&this._updateLargestRange():(!this._largestRange||e.count>this._largestRange.count)&&(this._largestRange=e)}findBestRange(e){let t=this._parent._freeHead,s=null;for(;null!==t;)t.count>=e&&(!s||t.count-e<s.count-e)&&(s=t),t=t.next;return s}findAdjacentRanges(e,t){let s=!0,i=!1,r=null,n=this._parent._freeHead;for(;s&&!i;)e>=(null!==r?r.from+r.count:0)&&e+t<=(null!==n?n.from:this._parent._size)?(s=!1,i=!0):null!==n?(r=n,n=n.next):s=!1;return[r,n]}_updateLargestRange(){let e=null,t=this._parent._freeHead;for(;null!==t;)(!e||t.count>e.count)&&(e=t),t=t.next;this._largestRange=e}}class P{constructor(e,t){this._allocated=0,this._size=e,this._freeHead=e>0?{from:0,count:e,prev:null,next:null}:null,this._bookKeeper=t||new K(this),this._freeHead&&this._bookKeeper.rangeCreated(this._freeHead)}allocate(e){const t=this._bookKeeper.findBestRange(e);if(null==t)return-1;const s=t.from,i=t.count;if(t.from+=e,t.count-=e,this._bookKeeper.rangeResized(t,s,i),this._allocated+=e,0===t.count){const r=null!==t.prev?this._freeHead:t.next;P._removeRange(t),this._freeHead=r}return s}free(e,t){const[s,i]=this._bookKeeper.findAdjacentRanges(e,t),r={from:e,count:t,prev:s??null,next:i??null};if(null!=s&&(s.next=r),null!=i&&(i.prev=r),this._bookKeeper.rangeCreated(r),this._allocated-=t,null!=i&&r.from+r.count===i.from){const n=r.from,o=r.count;P._fuse(r,i),P._removeRange(i),this._bookKeeper.rangeResized(r,n,o),this._bookKeeper.rangeResized(i,void 0,0)}if(null!=s&&s.from+s.count===r.from){const n=s.from,o=s.count;P._fuse(s,r),P._removeRange(r),this._bookKeeper.rangeResized(s,n,o),this._bookKeeper.rangeResized(r,void 0,0)}this._freeHead=null!==r.prev?this._freeHead:r}get fragmentation(){const e=this._size-this._allocated;return 0===e?0:1-this._bookKeeper.largestRange.count/e}static _removeRange(e){null!==e.prev?null!==e.next?(e.prev.next=e.next,e.next.prev=e.prev):e.prev.next=null:null!==e.next&&(e.next.prev=null)}static _fuse(e,t){e.count+=t.count,e.next=t.next,t.from+=t.count,t.count=0,null!==t.next&&(t.next.prev=e)}}var R=g(87526);const D=["FILL","LINE","MARKER","TEXT","LABEL"];class A{constructor(e,t,s,i){this._strides=e,this._displayList=t,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=s;for(const r in e){this._freeListsAndStorage[r]={vtxFreeList:i?new P(i):null,idxFreeList:i?new P(i):null,vertexBuffers:{},indexBuffer:i?new Uint32Array(i):null};for(const n in e[r])this._freeListsAndStorage[r].vertexBuffers[n]={data:i?(0,R.C$)(i,e[r][n]):null,stride:e[r][n]}}}static fromTileData(e,t){const s=function S(a){const e=a.getStrides(),t={};for(let s=0;s<e.length;s++)t[D[s]]=e[s];return t}(e),i=[0,0,0,0,0],r=[0,0,0,0,0];for(const h of e.tileDisplayData.displayObjects)for(const m of h.displayRecords)i[m.geometryType]=Math.max(i[m.geometryType],m.vertexFrom+m.vertexCount),r[m.geometryType]=Math.max(r[m.geometryType],m.indexFrom+m.indexCount);const n=new A(s,e.tileDisplayData.displayList,t,void 0),o=e.tileBufferData?.geometries??[];for(let h=0;h<o.length;++h){const m=i[h],v=r[h],y=o[h],b=n._storageFor(D[h]),F=o[h].indexBuffer;b.indexBuffer=F,b.idxFreeList=new P(F.length),b.idxFreeList.allocate(v);let w=0;for(const te in y.vertexBuffer){const ne=o[h].vertexBuffer[te];b.vertexBuffers[te].data=ne.data,b.vertexBuffers[te].stride=ne.stride;const de=(0,R.Y8)(ne.stride);w||(w=ne.data.length*de/ne.stride)}b.vtxFreeList=new P(w),b.vtxFreeList.allocate(m)}return n}delete(e){const t=D[e.geometryType];this._freeVertices(t,e.vertexFrom,e.vertexCount),this._freeIndices(t,e.indexFrom,e.indexCount),this._displayList.removeFromList(e),e.vertexFrom=void 0,e.indexFrom=void 0}setMeshData(e,t,s,i,r){const n=D[e.geometryType];let o,h;e.meshData=null,void 0===e.vertexFrom?(h=t.vertexCount,o=this._allocateVertices(n,h)):t.vertexCount>e.vertexCount?(this._freeVertices(n,e.vertexFrom,e.vertexCount),h=t.vertexCount,o=this._allocateVertices(n,h)):t.vertexCount===e.vertexCount?(o=e.vertexFrom,h=e.vertexCount):(this._freeVertices(n,e.vertexFrom+t.vertexCount,e.vertexCount-t.vertexCount),o=e.vertexFrom,h=t.vertexCount);let m,v,y,x=!0;if(void 0===e.indexFrom?(m=r,y=t.indexCount,v=this._allocateIndices(n,y)):t.indexCount>e.indexCount?(m=this._displayList.removeFromList(e),this._freeIndices(n,e.indexFrom,e.indexCount),y=t.indexCount,v=this._allocateIndices(n,y)):t.indexCount===e.indexCount?(x=!1,v=e.indexFrom,y=e.indexCount):(m=this._displayList.removeFromList(e),this._freeIndices(n,e.indexFrom+t.indexCount,e.indexCount-t.indexCount),v=e.indexFrom,y=t.indexCount),-1!==o&&-1!==v){const b=this._storageFor(n);if((0,R.wO)(o,v,b.vertexBuffers,b.indexBuffer,t,s,i),e.vertexFrom=o,e.indexFrom=v,e.vertexCount=t.vertexCount,e.indexCount=t.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const F in s)this._dirtyMap.markDirtyVertices(e.geometryType,F,e.vertexFrom,e.vertexCount)}return x&&this._displayList.addToList(e,m),!0}return-1!==o&&this._freeVertices(n,o,h),-1!==v&&this._freeIndices(n,v,y),e.setMeshDataFromBuffers(t,s,i),e.vertexFrom=void 0,e.vertexCount=0,e.indexFrom=void 0,e.indexCount=0,!1}tryAddMeshData(e,t){const s=t.vertexBuffer,i=t.indexBuffer,r=D[e.geometryType],n=this._allocateVertices(r,e.vertexCount);if(-1===n)return this._freeVertices(r,n,e.vertexCount),!1;const o=this._allocateIndices(r,e.indexCount);if(-1===o)return this._freeVertices(r,n,e.vertexCount),this._freeIndices(r,o,e.indexCount),!1;const h=this._storageFor(r);if((0,R.wO)(n,o,h.vertexBuffers,h.indexBuffer,e,s,i),e.vertexFrom=n,e.indexFrom=o,this._dirtyMap){this._dirtyMap.markDirtyIndices(e.geometryType,e.indexFrom,e.indexCount);for(const m in s)this._dirtyMap.markDirtyVertices(e.geometryType,m,n,e.vertexCount)}return this._displayList.addToList(e),!0}_allocateVertices(e,t){const s=this._storageFor(e),i=s.vtxFreeList?.allocate(t);if(null==i||-1===i)return-1;const r=s.vtxFreeList?.fragmentation;return null==r||r>.5?-1:i}_freeVertices(e,t,s){this._storageFor(e).vtxFreeList?.free(t,s)}_freeIndices(e,t,s){this._storageFor(e).idxFreeList?.free(t,s)}_allocateIndices(e,t){const s=this._storageFor(e),i=s.idxFreeList?.allocate(t);if(null==i||-1===i)return-1;const r=s.idxFreeList?.fragmentation;return null==r||r>.5?-1:i}_storageFor(e){return this._freeListsAndStorage[e]}_stridesFor(e,t){return this._strides[e][t]}}var V=g(83994),B=g(67969),j=g(49353);class he{constructor(e){this.geometryMap=(0,R.Mk)(()=>({indexBuffer:V.f.createIndex(e,B.l1.STATIC_DRAW),vao:null}),(t,s)=>({vertexBuffer:V.f.createVertex(e,R.Bw[s])}))}dispose(){for(let e=0;e<5;e++){const t=this.geometryMap[e];if(t){t.data.vao?.disposeVAOOnly(),t.data.indexBuffer?.dispose();for(const s in t.buffers)t.buffers[s]?.data.vertexBuffer.dispose()}}}get(e){const t=this.geometryMap[e];return{getVAO(s,i,r){if(!t.data.vao){const n={};for(const o in t.buffers)n[o]=t.buffers[o].data.vertexBuffer;t.data.vao=new j.U(s,r,i,n,t.data.indexBuffer)}return t.data.vao}}}has(e){return null!=this.geometryMap[e]}upload(e,t){t.forEach((s,i)=>{this._upload(s,i,e)})}_upload(e,t,s){if(e.indices&&(e.indices.allDirty?this._uploadIndices(s,t):null!=e.indices.from&&null!=e.indices.count&&this._uploadIndices(s,t,e.indices.from,e.indices.count)),e.vertices){const i=e.vertices;for(const r in i){const n=i[r];n.allDirty?this._uploadVertices(s,t,r):null!=n.from&&null!=n.count&&this._uploadVertices(s,t,r,n.from,n.count)}}}_uploadVertices(e,t,s,i,r){const n=this.geometryMap[t];if(!n)return;const o=e.geometries[t].vertexBuffer[s];if(!o)return;const{data:h,stride:m}=o;if(n.buffers[s]&&h.length>0){const v=m/h.BYTES_PER_ELEMENT;null!=i&&null!=r?n.buffers[s].data.vertexBuffer.setSubData(h,i*v,i*v,(i+r)*v):n.buffers[s].data.vertexBuffer.setData(h)}}_uploadIndices(e,t,s,i){const r=this.geometryMap[t];if(!r)return;const n=e.geometries[t].indexBuffer;r.data.indexBuffer&&n.length>0&&(null!=s&&null!=i?r.data.indexBuffer.setSubData(n,s,s,s+i):r.data.indexBuffer.setData(n))}}var G=g(29443);class Ce extends G.o{constructor(){super(...arguments),this._data=null,this._displayList=null,this._lastCommitTime=0,this._hasData=!1,this._invalidated=!1,this._wglBuffers=null,this._dirtyMap=new O}destroy(){super.destroy(),this.clear()}get hasData(){return!!this._hasData}get displayObjects(){return this._displayObjects??[]}getGeometry(e){return this._wglBuffers&&this._wglBuffers.has(e)?this._wglBuffers.get(e):null}getDisplayList(){return this._displayList}patch(e){if(!0===e.clear)return this.clear(),void(this._hasData=!1);const t=e.addOrUpdate,s=e.remove;!this._data&&t?.tileDisplayData?.displayObjects.length?(t.tileDisplayData.computeDisplayList(),this._dirtyMap=new O,this._dispRecStore=A.fromTileData(t,this._dirtyMap),this._data=t,this._dirtyMap.markAllDirty(),this._hasData=!0,e.end&&this.ready()):this._data&&(t?.tileDisplayData?.displayObjects.length||s.length)?this._doPatchData(e):e.end&&this.ready(),e.end&&!this._data&&this.clear(),this.requestRender(),this.emit("change")}commit(e){e.time&&e.time===this._lastCommitTime||(this._lastCommitTime=e.time,this.visible&&this._data&&(this._wglBuffers||(this._wglBuffers=new he(e.context)),(this._dirtyMap.hasDirty()||this._invalidated)&&(this._invalidated=!1,this._wglBuffers.upload(this._data.tileBufferData,this._dirtyMap),this._displayList=this._data.tileDisplayData.displayList.clone(),this._displayObjects=this._data.tileDisplayData.displayObjects.slice(),this._dirtyMap.markAllClean())))}clear(){this._data=null,this._displayList=null,this._dispRecStore=null,this._wglBuffers&&(this._wglBuffers.dispose(),this._wglBuffers=null)}_doPatchData(e){this._invalidated=!0,this._patchData(e)||(this._dirtyMap.markAllDirty(),this._data.reshuffle(),this._dispRecStore=A.fromTileData(this._data,this._dirtyMap)),this.requestRender()}_patchData(e){let t=!0;const s=e.addOrUpdate?.tileDisplayData?.displayObjects||[],i=(e.remove||[]).slice();for(const o of s)null!=o.insertAfter&&i.push(o.id);let r;i.length>0&&(r=new Set(i));const n=this._data.tileDisplayData;for(const o of i){const h=n.displayObjectRegistry.get(o);if(h){n.displayList.removeFromList(h.displayRecords);for(const m of h.displayRecords)this._dispRecStore.delete(m);n.displayObjectRegistry.delete(o)}}r?.size&&(n.displayObjects=n.displayObjects.filter(o=>!r.has(o.id)));for(const o of s){let h,m=n.displayObjectRegistry.get(o.id);if(m){const y=m.displayRecords;m.set(o),m.displayRecords=y;const x=m.displayRecords.length;for(let b=0;b<x;++b){const F=m.displayRecords[b],w=o.displayRecords[b];(b>=o.displayRecords.length||F.geometryType!==w.geometryType||F.symbolLevel!==w.symbolLevel||F.zOrder!==w.zOrder||F.materialKey!==w.materialKey)&&(this._dispRecStore.delete(m.displayRecords[b]),b<o.displayRecords.length&&(m.displayRecords[b]=void 0))}m.displayRecords.length=o.displayRecords.length}else{let y;m=o.copy(),m.displayRecords=[],n.displayObjectRegistry.set(o.id,m);const x=n.displayObjects;if(null!=m.insertAfter)if(h={},m.insertAfter>=0){const b=n.displayObjectRegistry.get(m.insertAfter);b?(y=x.indexOf(b)+1,y<x.length?x.splice(y,0,m):(x.push(m),y=x.length)):(x.push(m),y=x.length)}else x.unshift(m),y=0;else x.push(m),y=x.length;if(h){const b=o.displayRecords.length>0?1:0;let F=0;for(let w=y-1;w>=0&&F<b;--w)for(let te=x[w].displayRecords.length-1;te>=0&&F<b;--te){const ne=x[w].displayRecords[te],de=n.displayList.getDPInfoType();h[de]||(h[de]=ne,++F)}}}const v=o.displayRecords.length;for(let y=0;y<v;++y){const x=o.displayRecords[y];let b=m.displayRecords[y];b?(b.meshData=x.meshData,b.materialKey=x.materialKey):(b=x.copy(),b.vertexFrom=void 0,b.indexFrom=void 0,m.displayRecords[y]=b);const F=x.geometryType,w=n.displayList.getDPInfoType(),te=e.addOrUpdate.tileBufferData.geometries[F],ne=te.vertexBuffer,de=te.indexBuffer;let ce;h&&(ce=h[w]?n.displayList.splitAfter(h[w]):-1),t=this._dispRecStore.setMeshData(b,x,ne,de,ce)&&t,h&&null!=b.indexFrom&&null!=b.indexFrom&&(h[w]=b)}}return t}}class ue{constructor(){this._byGeometryType=null}get satisfied(){return!this._byGeometryType}reset(){this._byGeometryType=null}verticesFor(e){return this._byGeometryType?this._byGeometryType[e].vertices:0}indicesFor(e){return this._byGeometryType?this._byGeometryType[e].indices:0}needMore(e,t,s){if(!t&&!s)return;this._byGeometryType||(this._byGeometryType=[{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0}]);const i=this._byGeometryType[e];i.vertices+=t,i.indices+=s}}class re{constructor(){this.geometries=[{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}}]}clone(){const e=new re;for(let t=0;t<this.geometries.length;t++){const s=this.geometries[t],i=e.geometries[t];i.indexBuffer=s.indexBuffer.slice(),i.vertexBuffer={};for(const r in s.vertexBuffer){const{data:n,stride:o}=s.vertexBuffer[r];i.vertexBuffer[r]={data:n.slice(),stride:o}}}return e}static deserialize(e){const t=new re;for(let s=0;s<5;++s){t.geometries[s].indexBuffer=new Uint32Array(e.geometries[s].indexBuffer),t.geometries[s].vertexBuffer={};for(const i in e.geometries[s].vertexBuffer)t.geometries[s].vertexBuffer[i]={data:(0,R.e2)(e.geometries[s].vertexBuffer[i].data,e.geometries[s].vertexBuffer[i].stride),stride:e.geometries[s].vertexBuffer[i].stride}}return t}serialize(){const e={geometries:[{indexBuffer:this.geometries[0].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[1].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[2].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[3].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[4].indexBuffer.buffer,vertexBuffer:{}}]};for(let t=0;t<5;++t)for(const s in this.geometries[t].vertexBuffer)e.geometries[t].vertexBuffer[s]={data:this.geometries[t].vertexBuffer[s].data.buffer,stride:this.geometries[t].vertexBuffer[s].stride};return e}getBuffers(){const e=[];for(let t=0;t<5;++t){e.push(this.geometries[t].indexBuffer.buffer);for(const s in this.geometries[t].vertexBuffer)e.push(this.geometries[t].vertexBuffer[s].data.buffer)}return e}}var Ne=g(18716);function Be(a,e,t,...s){e<a.length?a.splice(e,t,...s):a.push(...s)}class ze{constructor(){this.symbolLevels=[]}replay(e,t,s){for(const i of this.symbolLevels)for(const r of i.zLevels){const n=r.geometryDPInfo.unified;if(n)for(const o of n){const{geometryType:h,materialKey:m,indexFrom:v,indexCount:y}=o,x=Ne.m2.load(m).symbologyType,b=e.painter.getBrush(h,x),F={geometryType:h,materialKey:m,indexFrom:v,indexCount:y,target:t.getGeometry(h)};b.prepareState(e),b.drawGeometry(e,t,F,s)}}}get empty(){return!this.symbolLevels||0===this.symbolLevels.length}clear(){this.symbolLevels.length=0}addToList(e,t){if(Array.isArray(e))for(const s of e)this._addToList(s,t);else this._addToList(e,t)}removeFromList(e){Array.isArray(e)||(e=[e]);let t=null;for(const s of e)t=this._removeFromList(s);return t}clone(){const e=new ze;for(const t of this.symbolLevels)e.symbolLevels.push(t.clone());return e}splitAfter(e){const t=this._getDisplayList(e.symbolLevel,e.zOrder),s=t.length,i=e.indexFrom+e.indexCount;for(let r=0;r<s;++r){const n=t[r];if(n.geometryType===e.geometryType&&i>n.indexFrom&&i<=n.indexFrom+n.indexCount){if(i<n.indexFrom+n.indexCount){const o=new be;o.geometryType=n.geometryType,o.materialKey=n.materialKey,o.indexFrom=i,o.indexCount=n.indexFrom+n.indexCount-i,t.splice(r+1,0,o),n.indexCount=i-n.indexFrom}return r}}}_addToList(e,t){const r=this._getDisplayList(e.symbolLevel,e.zOrder),n=t??r.length-1,o=n>=0&&n<r.length?r[n]:null;if(null!==o&&o.materialKey===e.materialKey&&o.indexFrom+o.indexCount===e.indexFrom&&o.geometryType===e.geometryType)o.indexCount+=e.indexCount;else{const h=new be;h.indexFrom=e.indexFrom,h.indexCount=e.indexCount,h.materialKey=e.materialKey,h.geometryType=e.geometryType,Be(r,n+1,0,h)}}_removeFromList(e){const i=this._getDisplayList(e.symbolLevel,e.zOrder),r=i.length;let n;for(let o=0;o<r;++o){const h=i[o];if(e.indexFrom+e.indexCount>h.indexFrom&&e.indexFrom<h.indexFrom+h.indexCount&&h.geometryType===e.geometryType){n=o;break}}if(void 0!==n){const o=i[n];if(e.indexFrom===o.indexFrom)return o.indexCount-=e.indexCount,o.indexFrom+=e.indexCount,0===o.indexCount&&Be(i,n,1),n-1;if(e.indexFrom+e.indexCount===o.indexFrom+o.indexCount)return o.indexCount-=e.indexCount,0===o.indexCount?(Be(i,n,1),n-1):n;{const h=o.indexFrom,m=e.indexFrom-o.indexFrom,v=e.indexCount,y=o.indexFrom+o.indexCount-(e.indexFrom+e.indexCount);o.indexCount=m;const x=new be;return x.geometryType=o.geometryType,x.materialKey=o.materialKey,x.indexFrom=h+m+v,x.indexCount=y,Be(i,n+1,0,x),n}}return null}_getDisplayList(e,t){let s;const i=this.symbolLevels.length;for(let o=0;o<i;o++)if(this.symbolLevels[o].symbolLevel===e){s=this.symbolLevels[o];break}let r;s||(s=new Ee,s.symbolLevel=e,this.symbolLevels.push(s));const n=s.zLevels.length;for(let o=0;o<n;o++)if(s.zLevels[o].zLevel===t){r=s.zLevels[o];break}return r||(r=new Ae,r.geometryDPInfo=new Ie,r.zLevel=t,s.zLevels.push(r)),r.geometryDPInfo.unified||(r.geometryDPInfo.unified=[]),r.geometryDPInfo.unified}getDPInfoType(){return"unified"}}class be{constructor(){this.materialKey=null,this.indexFrom=0,this.indexCount=0}clone(){const e=new be;return e.geometryType=this.geometryType,e.materialKey=this.materialKey,e.indexFrom=this.indexFrom,e.indexCount=this.indexCount,e}}class Ie{constructor(){this.fill=null,this.line=null,this.marker=null,this.text=null,this.label=null,this.unified=null}clone(){const e=new Ie;return e.fill=this.fill&&this.fill.map(t=>t.clone()),e.line=this.line&&this.line.map(t=>t.clone()),e.marker=this.marker&&this.marker.map(t=>t.clone()),e.text=this.text&&this.text.map(t=>t.clone()),e.label=this.label&&this.label.map(t=>t.clone()),e.unified=this.unified&&this.unified.map(t=>t.clone()),e}}class Ae{constructor(){this.geometryDPInfo=new Ie}clone(){const e=new Ae;return e.zLevel=this.zLevel,e.geometryDPInfo=this.geometryDPInfo.clone(),e}}class Ee{constructor(){this.zLevels=[]}clone(){const e=new Ee;e.symbolLevel=this.symbolLevel;for(const t of this.zLevels)e.zLevels.push(t.clone());return e}}class je{constructor(){this.vertexData=new Map,this.vertexCount=0,this.indexData=[]}clear(){this.vertexData.clear(),this.vertexCount=0,this.indexData=[]}update(e,t,s){for(const i in e)this.vertexData.set(i,e[i]);for(const i in this.vertexData)null===e[i]&&this.vertexData.delete(i);this.vertexCount=t,this.indexData=s}}class pe{constructor(e,t,s,i=0,r=0){this.id=e,this.geometryType=t,this.materialKey=s,this.minZoom=i,this.maxZoom=r,this.meshData=null,this.symbolLevel=0,this.zOrder=0,this.vertexFrom=0,this.vertexCount=0,this.indexFrom=0,this.indexCount=0,this._sortKey=null}get sortKey(){return null==this._sortKey&&this._computeSortKey(),this._sortKey}clone(){return this.copy()}copy(){const e=new pe(this.id,this.geometryType,this.materialKey);return e.vertexFrom=this.vertexFrom,e.vertexCount=this.vertexCount,e.indexFrom=this.indexFrom,e.indexCount=this.indexCount,e.zOrder=this.zOrder,e.symbolLevel=this.symbolLevel,e.meshData=this.meshData,e.minZoom=this.minZoom,e.maxZoom=this.maxZoom,e}setMeshDataFromBuffers(e,t,s){const i=new je;for(const r in t){const n=t[r].stride,o=t[r].data;if(!o)continue;const h=[],m=(0,R.Y8)(n);for(let v=0;v<n*e.vertexCount/m;++v)h[v]=o[v+n*e.vertexFrom/m];i.vertexData.set(r,h)}i.indexData.length=0;for(let r=0;r<e.indexCount;++r)i.indexData[r]=s[r+e.indexFrom]-e.vertexFrom;i.vertexCount=e.vertexCount,this.meshData=i}readMeshDataFromBuffers(e,t){this.meshData?this.meshData.clear():this.meshData=new je;for(const s in e){const i=e[s].stride,r=e[s].data,n=[],o=(0,R.Y8)(i);for(let h=0;h<i*this.vertexCount/o;++h)n[h]=r[h+i*this.vertexFrom/o];this.meshData.vertexData.set(s,n)}this.meshData.indexData.length=0;for(let s=0;s<this.indexCount;++s)this.meshData.indexData[s]=t[s+this.indexFrom]-this.vertexFrom;this.meshData.vertexCount=this.vertexCount}writeMeshDataToBuffers(e,t,s,i){if(this.meshData){for(const r in t){const n=t[r].stride,o=this.meshData.vertexData.get(r),h=t[r].data,m=(0,R.Y8)(n);for(let v=0;v<n*this.meshData.vertexCount/m;++v)h[v+n*e/m]=o[v]}for(let r=0;r<this.meshData.indexData.length;++r)i[r+s]=this.meshData.indexData[r]+e;this.vertexFrom=e,this.vertexCount=this.meshData.vertexCount,this.indexFrom=s,this.indexCount=this.meshData.indexData.length}}static writeAllMeshDataToBuffers(e,t,s){let i=0,r=0;for(const n of e)n.writeMeshDataToBuffers(i,t,r,s),i+=n.vertexCount,r+=n.indexCount}_computeSortKey(){this._sortKey=(31&this.symbolLevel)<<12|(127&this.zOrder)<<4|7&this.geometryType}serialize(e){return e.push(this.geometryType),e.push(this.materialKey),e.push(this.vertexFrom),e.push(this.vertexCount),e.push(this.indexFrom),e.push(this.indexCount),e.push(this.minZoom),e.push(this.maxZoom),e}static deserialize(e,t){const s=e.readInt32(),i=e.readInt32(),r=new pe(t.id,s,i);return r.vertexFrom=e.readInt32(),r.vertexCount=e.readInt32(),r.indexFrom=e.readInt32(),r.indexCount=e.readInt32(),r.minZoom=e.readInt32(),r.maxZoom=e.readInt32(),r}}function Ve(a,e){if(null!==e){a.push(e.length);for(const t of e)t.serialize(a);return a}a.push(0)}class me{constructor(e){this.insertAfter=null,this.id=e,this.displayRecords=[]}copy(){const e=new me(this.id);return e.set(this),e}clone(){const e=new me(this.id);return e.displayRecords=this.displayRecords.map(t=>t.clone()),e.insertAfter=this.insertAfter,e}set(e){this.id=e.id,this.displayRecords=e.displayRecords,this.insertAfter=e.insertAfter}serialize(e){return e.push(this.id),Ve(e,this.displayRecords),e}static deserialize(e){const t=e.readInt32(),s=new me(t);return s.displayRecords=function Xe(a,e,t){const s=a.readInt32(),i=new Array(s);for(let r=0;r<i.length;r++)i[r]=e.deserialize(a,t);return i}(e,pe,{id:t})??[],s}}class De{constructor(){this.displayObjects=[],this._displayList=null}get displayObjectRegistry(){if(!this._displayObjectRegistry){this._displayObjectRegistry=new Map;for(const e of this.displayObjects)this._displayObjectRegistry.set(e.id,e)}return this._displayObjectRegistry}get displayList(){return this._displayList}computeDisplayList(){this._displayList=new ze;for(const e of this.displayObjects)for(const t of e.displayRecords)this._displayList.addToList(t)}clone(){const e=new De;return this.displayObjects&&(e.displayObjects=this.displayObjects.map(t=>t.clone())),e}serialize(e){return Ve(e,this.displayObjects),e}_deserializeObjects(e){const t=e.readInt32(),s=new Array(t),i=new Map;for(let r=0;r<s.length;++r){const n=me.deserialize(e);s[r]=n,i.set(n.id,n)}this.displayObjects=s,this._displayList=null,this._displayObjectRegistry=i}static deserialize(e){const t=new De;return t._deserializeObjects(e),t}}var $e=g(37633);class ye{constructor(e,t){this.data=e,this.stride=t}static decode(e){const t=(0,R.e2)(e.data,e.stride);return new ye(t,e.stride)}static fromVertexVector(e){const t=(0,R.e2)(e.data.buffer(),e.stride);return new ye(t,e.stride)}}class ge{constructor(e,t,s){this.geometryType=e,this.indexBuffer=new Uint32Array(t),this.namedBuffers=s}static decode(e){const t=e.geometryType,s=e.indexBuffer,i={};for(const r in e.namedBuffers)i[r]=ye.decode(e.namedBuffers[r]);return new ge(t,s,i)}static fromVertexData(e,t){const s=e.indices,i=(0,R.e2)(e.vertices,e.stride),n={geometry:new ye(i,e.stride)};return new ge(t,s,n)}static fromVertexVectors(e){const t=e.geometryType,s=e.indexVector.buffer(),i={};let r;for(r in e.namedVectors)i[r]=ye.fromVertexVector(e.namedVectors[r]);return new ge(t,s,i)}}var Me=g(75734);class Ye{get vertexCount(){const t=this.data.length/(this.stride/4);return t!==(0|t)&&console.debug("Corrupted stride"),t}constructor(e,t){this.data=e,this.stride=t}transfer(e,t){const s=this.data.buffer();e.vertexCount=this.vertexCount,e.data=s,e.stride=this.stride,t.push(s)}}class Je{constructor(e,t,s){this.geometryType=e,this.indexVector=new Me.Z(Uint32Array,6*t),this.namedVectors={};const i=(0,R.$_)(e,s);for(const r in i){const n=i[r];let o;switch(n%4){case 0:case 2:o=new Me.Z(Uint32Array,n*t);break;case 1:case 3:o=new Me.Z(Uint8Array,n*t)}this.namedVectors[r]=new Ye(o,n)}}get(e){return this.namedVectors[e].data}getVector(e){return this.namedVectors[e]}transfer(e,t){const s=this.indexVector.buffer(),i={};let r;for(r in t.push(s),this.namedVectors){const n=this.namedVectors[r];i[r]={},n.transfer(i[r],t)}e.geometryType=this.geometryType,e.indexBuffer=s,e.namedBuffers=i,this.destroy()}intoBuffers(){const e=ge.fromVertexVectors(this);return this.destroy(),e}destroy(){this.indexVector=null,this.namedVectors=null}}const Re=new ue,xe=new ue;function ke(a,e){const t={};for(const s in a){const i={data:(0,R.C$)(e,a[s]),stride:a[s]};t[s]=i}return t}class oe{constructor(){this.tileDisplayData=null,this.tileBufferData=null}reshuffle(){if(Re.reset(),!this.tileDisplayData)return;const e=function et(a){const e=[[],[],[],[],[]],t=a;for(const s of t)for(const i of s.displayRecords)e[i.geometryType].push(i);return e}(this.tileDisplayData.displayObjects);for(const n of e)for(const o of n)o&&Re.needMore(o.geometryType,o.meshData?o.meshData.vertexCount:o.vertexCount,o.meshData?o.meshData.indexData.length:o.indexCount);const t=e.length,s=new re;for(let n=0;n<t;++n){s.geometries[n].indexBuffer=new Uint32Array(Math.round(E._X*Re.indicesFor(n)));const o=[],h=this.tileBufferData?.geometries[n].vertexBuffer;if(!h)continue;for(const x in h)o.push(h[x].stride);const m=oe._computeVertexAlignment(o),v=Math.round(E._X*Re.verticesFor(n)),y=oe._align(v,m);for(const x in h){const b=h[x].stride;s.geometries[n].vertexBuffer[x]={stride:b,data:(0,R.C$)(y,b)}}}xe.reset(),this.tileDisplayData.displayList?.clear();for(let n=0;n<t;++n){const o=e[n];for(const h of o){if(h.meshData)h.writeMeshDataToBuffers(xe.verticesFor(n),s.geometries[n].vertexBuffer,xe.indicesFor(n),s.geometries[n].indexBuffer),h.meshData=null;else{const m=this.tileBufferData?.geometries[n];if(m){const v=m.vertexBuffer,y=m.indexBuffer,x=s.geometries[n].vertexBuffer,b=s.geometries[n].indexBuffer,F=xe.verticesFor(n),w=xe.indicesFor(n);(0,R.wO)(F,w,x,b,h,v,y),h.vertexFrom=F,h.indexFrom=w}}xe.needMore(n,h.vertexCount,h.indexCount)}}const{displayList:i,displayObjects:r}=this.tileDisplayData;if(i)for(const n of r)i.addToList(n.displayRecords);this.tileBufferData=s}getStrides(){const e=[],t=this.tileBufferData?.geometries;if(!t)return e;for(let s=0;s<t.length;++s){const i=t[s];e[s]={};for(const r in i.vertexBuffer)e[s][r]=i.vertexBuffer[r].stride}return e}clone(){const e=new oe;return e.tileBufferData=this.tileBufferData?.clone()??null,e.tileDisplayData=this.tileDisplayData?.clone()??null,e}_guessSize(){const e=this.tileDisplayData?.displayObjects??[],t=Math.min(e.length,4);let r=0;for(let n=0;n<t;n++)r=Math.max(r,e[n].displayRecords.length);return 2*(12*e.length+e.length*r*40)}serialize(){const e=this.tileBufferData.serialize(),t=this.tileBufferData.getBuffers(),s=this.tileDisplayData.serialize(new Me.Z(Int32Array,this._guessSize())).buffer();return t.push(s),{result:{displayData:s,bufferData:e},transferList:t}}static fromVertexData(e,t){const s={},i=new Map;for(const r of t)i.set(r.id,r);return(0,R.Z_)(r=>{const n=e.data[r];if(null!=n){const o=$e.$.from(n.records).getCursor();for(;o.next();){const h=o.id,m=o.materialKey,v=o.indexFrom,y=o.indexCount,x=o.vertexFrom,b=o.vertexCount,F=i.get(h),w=new pe(h,r,m);w.indexFrom=v,w.indexCount=y,w.vertexFrom=x,w.vertexCount=b,F.displayRecords.push(w)}s[r]=ge.fromVertexData(n,r)}else s[r]=new Je(r,0,C.mD.DEFAULT).intoBuffers()}),oe.fromMeshData({displayObjects:t,vertexBuffersMap:s})}static fromMeshData(e){const t=new oe,s=new De,i=new re;s.displayObjects=e.displayObjects;for(const r in e.vertexBuffersMap){const n=r,o=e.vertexBuffersMap[n];i.geometries[n].indexBuffer=o.indexBuffer,i.geometries[n].vertexBuffer=o.namedBuffers}return t.tileDisplayData=s,t.tileBufferData=i,t}static bind(e,t){const s=new oe;return s.tileDisplayData=e,s.tileBufferData=t,s}static create(e,t){const s=new oe;s.tileDisplayData=new De,s.tileDisplayData.displayObjects=e;const i=[0,0,0,0,0],r=[0,0,0,0,0],n=[[],[],[],[],[]];for(const m of e)for(const v of m.displayRecords)n[v.geometryType].push(v),i[v.geometryType]+=v.meshData.vertexCount,r[v.geometryType]+=v.meshData.indexData.length;const o=new re,h=function qe(a){return[a.fill||{},a.line||{},a.icon||{},a.text||{},a.label||{}]}(t);for(let m=0;m<5;m++){const v=new Uint32Array(r[m]),y=ke(h[m],i[m]);pe.writeAllMeshDataToBuffers(n[m],y,v),o.geometries[m]={indexBuffer:v,vertexBuffer:y}}return s.tileBufferData=o,s}static _align(e,t){const s=e%t;return 0===s?e:e+(t-s)}static _computeVertexAlignment(e){let t=!1,s=!1;for(const i of e)i%4==2?t=!0:i%4!=0&&(s=!0);return s?4:t?2:1}}var tt=g(55130),st=g(246),it=g(1825),rt=g(32940),Pe=g(49391),nt=g(36682),ot=g(93872),Te=g(82054),at=g(25208),lt=g(64822);class we extends lt.i{static from(e,t,s){const i=at.s.createInstance(),r=[],n=e.filter(o=>!!o.geometry);for(const o of n){const h=(0,c.Ji)(o.geometry);(0,Te.E7)(r,[o],h,!1,!1,t)}return new we(i,r,s)}constructor(e,t,s){super(e,t,null),this._transform=s}get geometryType(){const e=this._current;return e?e.geometryType:null}get insertAfter(){return this._current.insertAfter}readGraphic(){return this._current}getCursor(){return this.copy()}copy(){const e=new we(this.instance,this._features,this._transform);return this.copyInto(e),e}}var Oe=g(23841),dt=g(76279),ht=g(32442),ut=g(93555),ct=g(26933),ft=g(27105),ve=g(7848),Ze=g(88071);const Se=new Ze.Z,Ue=new Ze.Z,Ke="esriGeometryPolyline";function We(a){a.coords.length=0,a.lengths.length=0}class ae{constructor(){this.bounds=(0,H.Ue)(),this.graphic=null}static acquire(e=null,t,s,i,r){let n;return 0===ae._pool.length?n=new ae:(n=ae._pool.pop(),this._set.delete(n)),n.acquire(e,t,s,i,r),n}static release(e){e&&!this._set.has(e)&&(e.release(),this._pool.push(e),this._set.add(e))}static getCentroidQuantized(e,t){if((0,c.oU)(e.geometry)){const s=e.symbol;if(null==s)return null;if(s?.layers.length>0&&s.layers.some(i=>"text"===i.type||"marker"===i.type)){const i=(0,ft.tO)(e.geometry);return null!==i?(0,ve.RF)(t,{},{x:i[0],y:i[1]},!1,!1):null}}return null}acquire(e=null,t,s,i,r){e&&this.set(e,t,s,i,r)}release(){this.graphic=null,this.symbolResource=null,this.geometry=null}get symbol(){return this.symbolResource.symbol}set(e,t,s,i,r){this.graphic=e,this.geometry=s,this.symbolResource=t,this.bounds=i,r&&(this.size=r)}getGeometryQuantized(e,t,s,i){const r=this.geometry,n=(0,c.Ji)(r);if(null==n)return null;switch(n){case"esriGeometryPolygon":{const o=r,{rings:h}=o;if(!h||0===h.length)return null;let m;if(m=(0,ve.ym)(e,1===h.length&&2===h[0].length?{paths:[[h[0][0],h[0][1]]]}:this.geometry),!m&&(m=(0,ve.ym)(e,{x:h[0][0][0],y:h[0][0][1]}),m)){const{x:y,y:x}=m;return{rings:[[[y-1,x],[1,-1],[1,1],[-1,1],[-1,-1]]]}}return m}case"esriGeometryPolyline":{const o=r;We(Se),We(Ue);const h=o.hasZ??!1,m=o.hasM??!1;return(0,Te.u0)(Se,o),(0,Te.zj)(Ue,Se,h,m,Ke,e.scale[0]),(0,Te.Nh)(Se,Ue,h,m,Ke,e),(0,Te.J6)(Se,o.hasZ??!1,o.hasM??!1)}case"esriGeometryMultipoint":{const o=r,h=.5*i*Math.max(Math.abs(this.size[0])+this.size[2]-this.size[0],Math.abs(this.size[1])+this.size[3]-this.size[1]),m=(0,f.C5)(s);let v=o.points;if(m){const[y,x]=m.valid,b=x-y;v=v.filter(F=>{if(F[0]+h>x||F[0]-h<y){const w=[...F];return F[0]+h>x?w[0]-=b:w[0]+=b,(0,H.Zm)(t,F,h)||(0,H.Zm)(t,w,h)}return(0,H.Zm)(t,F,h)})}return 0===v.length?{points:v}:(0,ve.ym)(e,{points:v})}}return(0,ve.ym)(e,this.geometry)}}ae._pool=[],ae._set=new Set;var $=g(64596);const Fe={minX:0,minY:0,maxX:0,maxY:0},_e=(0,H.Ue)();function Le(a,e,t,s,i){return Fe.minX=e,Fe.minY=t,Fe.maxX=s,Fe.maxY=i,a.search(Fe)}function pt(a){return{minX:a.bounds[0],minY:a.bounds[1],maxX:a.bounds[2],maxY:a.bounds[3]}}class mt{constructor(e,t,s,i,r,n,o){this._graphics=i,this._onAdd=r,this._onRemove=n,this._hashToCIM=o,this._index=(0,dt.r)(9,pt),this._itemByGraphic=new Map,this._inflatedSizeHelper=new d.bP,this._tileInfoView=e,this._uidFieldName=s;const h=e.getClosestInfoForScale(t);h&&(this._resolution=this._tileInfoView.getTileResolution(h.level))}setResourceManager(e){this._cimResourceManager=e,this._hittestDrawHelper=new ct.Tu(e)}hitTest(e,t,s,i,r){e=(0,ut.or)(e,this._tileInfoView.spatialReference);const n=.5*i*window.devicePixelRatio*s;_e[0]=e-n,_e[1]=t-n,_e[2]=e+n,_e[3]=t+n;const o=.5*i*(s+$.OC),h=Le(this._index,e-o,t-o,e+o,t+o);if(!h||0===h.length)return[];const m=[],v=(0,H.Ue)(),y=(0,H.Ue)();for(const F of h){const{geometry:w,symbolResource:te}=F;this._getSymbolBounds(v,te,w,y,r),y[3]=y[2]=y[1]=y[0]=0,(0,H.kK)(v,_e)&&F.graphic?.visible&&m.push(F)}if(0===m.length)return[];const x=this._hittestDrawHelper,b=[];for(const F of m){const{geometry:w,symbolResource:te}=F,{hash:ne,textInfo:de}=te,ce=this._hashToCIM.get(ne);ce&&x.hitTest(_e,ce.symbol,w,de,r,i)&&b.push(F)}return b.sort(yt),b.map(F=>F.graphic)}getGraphicsData(e,t,s){const i=this._searchForItems(t);if(0===i.length||0===s.length)return[];i.sort((y,x)=>y.zorder-x.zorder),i[0].insertAfter=-1;for(let y=1;y<i.length;y++)i[y].insertAfter=i[y-1].graphic.uid;i.sort((y,x)=>y.graphic.uid-x.graphic.uid),s.sort((y,x)=>y.uid-x.uid);let r,n=0,o=0;const h=t.resolution,m=[],v={originPosition:"upperLeft",scale:[h,h],translate:[t.bounds[0],t.bounds[3]]};for(const y of s){for(o=-2;n<i.length;)if(r=i[n],n++,y.uid===r.graphic.uid){o=r.insertAfter;break}if(!r?.geometry||-2===o)continue;const x=r.getGeometryQuantized(v,t.bounds,this._tileInfoView.spatialReference,h),b={...r.graphic.attributes};b[this._uidFieldName]=y.uid,null==r.groupId&&(r.groupId=e.createTemplateGroup(r.symbol,null)),m.push({centroid:ae.getCentroidQuantized(r,v),geometry:x,attributes:b,symbol:r.symbol,groupId:r.groupId,insertAfter:o,zorder:r.zorder})}return m.sort((y,x)=>y.zorder-x.zorder),m}queryTileData(e,t){if(0===this._graphics.length)return[];const{bounds:s,resolution:i}=t,r=this._searchForItems(t),n=[];return 0===r.length||this._createTileGraphics(n,e,r,{originPosition:"upperLeft",scale:[i,i],translate:[s[0],s[3]]},t),n}has(e){return this._itemByGraphic.has(e)}getBounds(e){const t=this._itemByGraphic.get(e);return t?t.bounds:null}getAllBounds(){return Array.from(this._itemByGraphic.values()).filter(e=>e.graphic.visible).map(e=>e.bounds)}addOrModify(e,t,s){if(!e||null==t)return;this.has(e)&&this.remove(e),this._onAdd(e);const i=[0,0,0,0],r=this._getSymbolBounds(null,t,s,i,0),n=ae.acquire(e,t,s,r??null,i);return this._itemByGraphic.set(e,n),s&&this._index.insert(n),n.bounds}remove(e){if(!this._itemByGraphic.has(e))return;this._onRemove(e);const t=this._itemByGraphic.get(e);t?.bounds&&this._index.remove(t),this._itemByGraphic.delete(e)}updateZ(){const e=this._graphics.items;let t,s;for(let i=0;i<e.length;i++)s=e[i],t=this._itemByGraphic.get(s),t&&(t.zorder=i)}update(e,t,s){const i=this._itemByGraphic.get(e);i.groupId=null;const r=(0,H.d9)(i.bounds);this._index.remove(i);const n=this._getSymbolBounds(i.bounds,t,s,i.size,0);return null!=n&&i.set(e,t,s,n,i.size),s&&this._index.insert(i),{oldBounds:r,newBounds:i.bounds}}updateLevel(e){if(this._resolution===e)return;this._resolution=e,this._index.clear();const t=this._itemByGraphic,s=[];for(const[i,r]of t){const n=this._getSymbolBounds(r.bounds,r.symbolResource,r.geometry,r.size,0);r.geometry&&null!=n&&(r.bounds=n,s.push(r))}this._index.load(s)}clear(){this._itemByGraphic.clear(),this._index.clear()}_createTileGraphics(e,t,s,i,r){const n=this._uidFieldName,o=this._tileInfoView.spatialReference,{bounds:h,resolution:m}=r;let v,y,x,b;s.sort((F,w)=>F.zorder-w.zorder);for(let F=0;F<s.length;F++){x=s[F],v=x.graphic,y=x.getGeometryQuantized(i,h,o,m),b=0===F?-1:s[F-1].graphic.uid;const w={...x.graphic.attributes};w[n]=v.uid,null==x.groupId&&(x.groupId=t.createTemplateGroup(x.symbol,null)),e.push({centroid:ae.getCentroidQuantized(x,i),geometry:y,attributes:w,symbol:x.symbol,groupId:x.groupId,insertAfter:b,zorder:x.zorder})}}_searchForItems(e){const t=this._tileInfoView.spatialReference,s=e.bounds,i=(0,f.C5)(t);if(i&&t.isWrappable){const[r,n]=i.valid,o=Math.abs(s[2]-n)<1e-5,h=Math.abs(s[0]-r)<1e-5;if((!o||!h)&&(o||h)){const m=e.resolution;let v;v=(0,H.Ue)(o?[r,s[1],r+m*$.OC,s[3]]:[n-m*$.OC,s[1],n,s[3]]);const y=Le(this._index,s[0],s[1],s[2],s[3]),x=Le(this._index,v[0],v[1],v[2],v[3]);return[...new Set([...y,...x])]}}return Le(this._index,s[0],s[1],s[2],s[3])}_getSymbolBounds(e,t,s,i,r){if(!t||!t.symbol||!s)return null;if(e||(e=(0,H.Ue)()),(0,ht.$P)(e,s),!i||0===i[0]&&0===i[1]&&0===i[2]&&0===i[3]){const{hash:h,textInfo:m}=t,v=this._hashToCIM.get(h);if(!v)return null;i||(i=[0,0,0,0]);const y=this._inflatedSizeHelper.getSymbolInflateSize(i,v.symbol,this._cimResourceManager,r,m);i[0]=(0,Oe.F2)(y[0]),i[1]=(0,Oe.F2)(y[1]),i[2]=(0,Oe.F2)(y[2]),i[3]=(0,Oe.F2)(y[3])}const n=this._resolution,o=d.bP.safeSize(i);return e[0]-=o*n,e[1]-=o*n,e[2]+=o*n,e[3]+=o*n,e}}const yt=(a,e)=>{const t=(0,$.eT)(a.graphic),s=(0,$.eT)(e.graphic);return t===s?e.zorder-a.zorder:t-s};var gt=g(51584),xt=g(31637),vt=g(3250);const _t=(0,X.Z)("esri-2d-graphic-debug");function Ge(a,e,t){let s=t.get(a);return s||(s={tile:e,addedOrModified:[],removed:[]},t.set(a,s)),s}let ie=class extends((0,ee.IG)(Y.Z)){constructor(a){super(a),this._storage=new ot.O,this._displayIds=new Map,this._controller=new AbortController,this._tiles=new Map,this._graphicStoreUpdate=!1,this._graphicsSet=new Set,this._matcher=Promise.resolve(null),this._tileUpdateSet=new Set,this._tilesToUpdate=new Map,this._graphicIdToAbortController=new Map,this._attached=!1,this._updatingGraphicsTimer=null,this._hashToExpandedSymbol=new Map,this._hashToExpandedSymbolPromise=new Map,this._hashToCIMSymbolPromise=new Map,this._hashToCIM=new Map,this._processing=!1,this._needsProcessing=!1,this._pendingUpdate={added:new Set,updated:new Set,removed:new Set},this.lastUpdateId=-1,this.renderer=null,this.updateRequested=!1,this.defaultPointSymbolEnabled=!0,this.graphicUpdateHandler=this.graphicUpdateHandler.bind(this)}destroy(){this._updatingGraphicsTimer&&(clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=null,this.notifyChange("updating")),this._controller.abort(),this.container.destroy(),this._set("graphics",null),this._graphicStore.clear(),this._attributeStore=null,this._hashToExpandedSymbol.clear(),this.view=null,this.renderer=null,this._hashToCIM.clear(),this._hashToCIMSymbolPromise.clear(),this._hashToExpandedSymbolPromise.clear()}_createMatcher(a,e,t){if(a){const s=(0,Pe.q5)(a),i=(0,Pe.MD)({indexCount:0,fields:{}},"feature",a,s);this._matcher=(0,rt.fL)(i,e,null,t)}}_createDisplayId(a){let e=this._displayIds.get(a);return e||(e=this._storage.createDisplayId(),this._displayIds.set(a,e)),e}initialize(){this._attributeStore=new nt.Z({type:"local",initialize:i=>Promise.resolve(this.container.attributeView.initialize(i)),update:i=>this.container.attributeView.requestUpdate(i),render:()=>this.container.requestRender()},(0,xt.hc)("2d")),this.container.checkHighlight=()=>this._attributeStore.hasHighlight;const t=new it.Wr(this.container.getMaterialItems.bind(this.container),this.view.featuresTilingScheme.tileInfo);this._graphicStore=new mt(this.view.featuresTilingScheme,this.view.state.scale,this.uid,this.graphics,i=>{this._createDisplayId(i.uid),this._setFilterState(i.uid,i.visible)},i=>{const r=this._displayIds.get(i.uid);this._displayIds.delete(i.uid),this._storage.releaseDisplayId(r)},this._hashToCIM),this._meshFactory=new st.j(null,this.uid,t),this._templateStore=t,this.addHandles([(0,Q.YP)(()=>this._effectiveRenderer,i=>{this._createMatcher(i,t,this.container.stage.resourceManager);for(const r of this.graphics)this._pendingUpdate.updated.add(r);this.requestUpdate()}),this.view.graphicsTileStore.on("update",this._onTileUpdate.bind(this)),this.container.on("attach",()=>{_t&&this.container.enableRenderingBounds(()=>this._graphicStore.getAllBounds()),this.graphics.items.length>0&&this._graphicsChangeHandler({target:this.graphics,added:this.graphics.items,removed:[],moved:[]}),this.addHandles(this.graphics.on("change",r=>this._graphicsChangeHandler(r)),"graphics");const i=this.container.stage.resourceManager;this._createMatcher(this._effectiveRenderer,t,i),this._graphicStore.setResourceManager(i),this._attached=!0,this.notifyChange("updating")})]),this._onTileUpdate({added:this.view.graphicsTileStore.tiles,removed:[]})}get _effectiveRenderer(){return"function"==typeof this.renderer?this.renderer():this.renderer}get updating(){return!this._attached||null!==this._updatingGraphicsTimer||this._pendingUpdate.added.size>0||this._pendingUpdate.removed.size>0||this._pendingUpdate.updated.size>0||this._tileUpdateSet.size>0||this._tilesToUpdate.size>0||this._attributeStore?.updatingHandles.updating||this._processing}hitTest(a){if(!this.view||this.view.suspended)return[];const{resolution:e,rotation:t}=this.view.state;return this._graphicStore.hitTest(a.x,a.y,2,e,t)}update(a){(0,I.k_)(this._controller.signal);const e=a.state,{resolution:t}=e;if(this._graphicStore.updateLevel(t),this._graphicStoreUpdate=!0,this.updateRequested=!1,this._pendingUpdate.updated.size>0){if(!this._processing)return void this._updateGraphics();this._needsProcessing=!0}}viewChange(){this.requestUpdate()}requestUpdate(){this.updateRequested||(this.updateRequested=!0,this.requestUpdateCallback())}processUpdate(a){this.updateRequested&&(this.updateRequested=!1,this.update(a))}graphicUpdateHandler(a){const{graphic:e,property:t}=a;switch(t){case"attributes":case"geometry":case"symbol":this._pendingUpdate.updated.add(e),this.requestUpdate();break;case"visible":this._setFilterState(e.uid,e.visible),this._attributeStore.sendUpdates()}}setHighlight(a){const e=a.map(t=>this._displayIds.get(t)).filter(E.pC);this._attributeStore.setHighlight(a,e)}_getIntersectingTiles(a){const e=this._graphicStore.getBounds(a);if(!e||0===(0,H.d_)(e)||0===(0,H.Cb)(e))return[];const t=(0,$.Zu)(e,this.view.spatialReference);return null!=t?[...new Set([...this.view.graphicsTileStore.boundsIntersections(t[0]),...this.view.graphicsTileStore.boundsIntersections(t[1])])]:this.view.graphicsTileStore.boundsIntersections(e)}_updateTile(a){var e=this;return(0,z.Z)(function*(){(0,I.k_)(e._controller.signal);const t=a.tile,s=e._getGraphicsData(e._templateStore,t,a.addedOrModified),i=yield e._processGraphics(t,s);return(0,I.k_)(e._controller.signal),e._patchTile(t.key,{type:"update",addOrUpdate:i,remove:a.removed,end:!0,clear:!1,sort:!1}),i})()}_patchTile(a,e){const t=this._tiles.get(a);t&&(this.container.onTileData(t,e),this.container.requestRender())}_graphicsChangeHandler(a){const e=this._pendingUpdate;for(const t of a.added)e.added.add(t);for(const t of a.moved)e.updated.add(t);for(const t of a.removed)this._pendingUpdate.added.has(t)?e.added.delete(t):e.removed.add(t);this._processing?this._needsProcessing=!0:this._updateGraphics()}_getGraphicsToUpdate(){const a={added:[],removed:[],updated:[]};if(!this.graphics)return a;const e=this._pendingUpdate;for(const t of this.graphics.items)e.added.has(t)?a.added.push(t):e.updated.has(t)&&a.updated.push(t);for(const t of e.removed)this._graphicStore.has(t)&&a.removed.push(t);return e.added.clear(),e.removed.clear(),e.updated.clear(),a}_updateGraphics(){var a=this;return(0,z.Z)(function*(){a._processing=!0;const{added:e,removed:t,updated:s}=a._getGraphicsToUpdate(),i=a._tilesToUpdate;let r;try{if(!a._graphicStoreUpdate){const y=a.view.state,{resolution:x}=y;a._graphicStore.updateLevel(x)}const n=[],o=new Array(e.length+t.length);for(let y=0;y<s.length;y++){const x=s[y],b=a._getIntersectingTiles(x);for(const F of b)r=F.id,Ge(r,F,i).removed.push(a._displayIds.get(x.uid));n.push(a._updateGraphic(x,null)),o[y]=x}const h=s.length;for(let y=0;y<e.length;y++){const x=e[y];o[h+y]=x,a._graphicsSet.add(x),n.push(a._addGraphic(x))}for(const y of t){a._abortProcessingGraphic(y.uid);const x=a._getIntersectingTiles(y);for(const b of x)r=b.id,Ge(r,b,i).removed.push(a._displayIds.get(y.uid));a._graphicsSet.delete(y),a._graphicStore.remove(y)}let m;a._flipUpdatingGraphics(),yield Promise.all(n);for(let y=0;y<o.length;y++){m=o[y];const x=a._getIntersectingTiles(m);for(const b of x)r=b.id,Ge(r,b,i).addedOrModified.push(m)}a._graphicStore.updateZ();const v=[];for(const[y,x]of i)v.push(a._updateTile(x));yield Promise.all(v)}catch(n){(0,I.D_)(n)}for(const n of t)try{const o=yield a._getSymbolForGraphic(n,null);if(o){const h=o.hash();a._hashToExpandedSymbol.delete(h)}}catch(o){(0,I.D_)(o)}i.clear(),a.notifyChange("updating"),a._processing=!1,a._needsProcessing&&(a._needsProcessing=!1,a._updateGraphics())})()}_getArcadeInfo(a){const e=(a.attributes?Object.keys(a.attributes):[]).map(t=>({name:t,alias:t,type:"string"==typeof a.attributes[t]?"esriFieldTypeString":"esriFieldTypeDouble"}));return null==a.geometry?null:{geometryType:(0,c.Ji)(a.geometry),spatialReference:Z.Z.fromJSON(a.geometry.spatialReference),fields:e}}_getSymbolForGraphic(a,e){return(0,I.k_)(this._controller.signal),null!=a.symbol?Promise.resolve(a.symbol):null!=this._effectiveRenderer?this._effectiveRenderer.getSymbolAsync(a,{scale:this.view.state.scale,signal:null!=e?e.signal:null}):Promise.resolve(this._getNullSymbol(a))}_getCIMSymbol(a,e,t){let s=this._hashToCIM.get(e);if(s)return Promise.resolve(s);const i=(0,d.rW)(a);if(null!=i){if("CIMSymbolReference"===i.type)return s=i,this._hashToCIM.set(e,s),Promise.resolve(s);let r=this._hashToCIMSymbolPromise.get(e);return r||(r=i.fetchCIMSymbol(t).then(n=>(this._hashToCIM.set(e,n.data),this._hashToCIMSymbolPromise.delete(e),n)).catch(n=>(this._hashToCIMSymbolPromise.delete(e),(0,I.r9)(n),null)),this._hashToCIMSymbolPromise.set(e,r),r)}return Promise.resolve(null)}_expandCIMSymbol(a,e,t,s){const i=this._hashToExpandedSymbol.get(t);if(i)return Promise.resolve(i);let r=this._hashToExpandedSymbolPromise.get(t);if(r)return r;const n=this.container.stage,o=this._getArcadeInfo(e),h=(0,Pe.q5)(null),m=(0,vt.createSymbolSchema)(a,h);return r=(0,gt.B)(m,o,n.resourceManager,s),this._hashToExpandedSymbolPromise.set(t,r),r.then(v=>(this._hashToExpandedSymbol.set(t,v),this._hashToExpandedSymbolPromise.delete(t),v)),r}_getSymbolResources(a,e){var t=this;return(0,z.Z)(function*(){return(0,I.k_)(t._controller.signal),t.container.stage?t._getSymbolForGraphic(a,e).then(s=>{if(!s)return null;const i=s.hash();return t._getCIMSymbol(s,i,e).then(r=>null==r?null:t._expandCIMSymbol(r,a,i,e).then(n=>{const o=n.layers.filter(h=>"text"===h.type&&"string"==typeof h.text);if(o&&o.length>0){const h=new Array(o.length);for(let v=0;v<o.length;v++){const y=o[v],x=[],[b]=(0,J.E)(y.text);y.text=b,"text"===s.type&&(y.lineWidth=s.lineWidth);for(let F=0;F<b.length;F++)x.push(b.charCodeAt(F));h[v]={symbol:y,id:v,glyphIds:x}}const m=new Map;return t.container.getMaterialItems(h).then(v=>{(0,q.O3)(v);for(let y=0;y<o.length;y++){const x=o[y];m.set(x.cim,{text:x.text,mosaicItem:v[y].mosaicItem})}return{symbol:n,textInfo:m,hash:i}})}return{symbol:n,hash:i}}))}).catch(s=>((0,I.r9)(s),null)):null})()}_projectAndNormalizeGeometry(a,e){var t=this;return(0,z.Z)(function*(){if((0,I.k_)(t._controller.signal),null==a.geometry||"mesh"===a.geometry.type)return null;let s=a.geometry;if((0,c.oU)(s))s.rings=s.rings;else if((0,c.l9)(s))s.paths=s.paths;else if((0,c.YX)(s)){const n=yield t._getSymbolForGraphic(a,e);(0,I.k_)(t._controller.signal),s=n&&((0,$.yA)(n.type)||(0,$.ab)(n.type))?s.center:(0,$.XA)(s)}yield(0,p._W)(s.spatialReference,t.view.spatialReference);const i=(0,T.SR)(s),r=(0,p.iV)(i,s.spatialReference,t.view.spatialReference);return r&&(0,k.pW)(r),r})()}_onTileUpdate(a){const e=(0,f.C5)(this.view.spatialReference);if(a.added&&a.added.length>0)for(const t of a.added)this._addNewTile(t,e);if(a.removed&&a.removed.length>0)for(const t of a.removed)this._removeTile(t.key)}_addGraphic(a){var e=this;return(0,z.Z)(function*(){e._abortProcessingGraphic(a.uid),(0,I.k_)(e._controller.signal);const t=new AbortController;e._graphicIdToAbortController.set(a.uid,t);const s={signal:t.signal};try{yield e._addOrUpdateGraphic(a,s),(0,I.k_)(e._controller.signal),e._graphicIdToAbortController.delete(a.uid)}catch(i){if(e._graphicIdToAbortController.delete(a.uid),!(0,I.D_)(i))throw i}})()}_updateGraphic(a,e){(0,I.k_)(this._controller.signal);const t=this._projectAndNormalizeGeometry(a,e),s=this._getSymbolResources(a,e);return Promise.all([t,s]).then(([i,r])=>{(0,I.k_)(this._controller.signal),this._graphicStore.addOrModify(a,r,i)})}_addOrUpdateGraphic(a,e){(0,I.k_)(this._controller.signal);const t=this._projectAndNormalizeGeometry(a,e),s=this._getSymbolResources(a,e);return Promise.all([t,s]).then(([i,r])=>{(0,I.k_)(this._controller.signal),this._graphicsSet.has(a)&&this._graphicStore.addOrModify(a,r,i)})}_addTile(a){const e=this.view.featuresTilingScheme.getTileBounds((0,H.Ue)(),a),t=this.view.featuresTilingScheme.getTileResolution(a.level),s=new Ce(a,t,e[0],e[3]);return this._tiles.set(a,s),this.container.addChild(s),s}_addNewTile(a,e){var t=this;return(0,z.Z)(function*(){const s=t._addTile(a.key),i=t._graphicStore.queryTileData(t._templateStore,a);if(0===i.length)return;if(e){const n=Math.round((e.valid[1]-e.valid[0])/a.resolution);for(const o of i)o.geometry&&((0,c.wp)(o.geometry)||(0,c.aW)(o.geometry))&&t._wrapPoints(o,n)}const r=a.key;t._tileUpdateSet.add(a.key),t.notifyChange("updating");try{const n={type:"update",clear:!1,addOrUpdate:yield t._processGraphics(a,i),remove:[],end:!0,sort:!1};s.patch(n),t._tileUpdateSet.delete(r),t.notifyChange("updating")}catch(n){if(t._tileUpdateSet.delete(r),t.notifyChange("updating"),!(0,I.D_)(n))throw n}})()}_removeTile(a){if(!this._tiles.has(a))return;const e=this._tiles.get(a);this.container.removeChild(e),e.destroy(),this._tiles.delete(a)}_setFilterState(a,e){const t=this._displayIds.get(a),s=this._attributeStore.getHighlightFlag(a);this._attributeStore.setData(t,0,0,s|(e?u.g3:0))}_getGraphicsData(a,e,t){const i=(0,f.C5)(this.view.spatialReference),r=this._graphicStore.getGraphicsData(a,e,t);if(i){const n=Math.round((i.valid[1]-i.valid[0])/e.resolution);for(const o of r)o.geometry&&((0,c.wp)(o.geometry)||(0,c.aW)(o.geometry))&&this._wrapPoints(o,n)}return r}_wrapPoints(a,e){const t=a.geometry;(0,c.aW)(t)?this._wrapMultipoint(t,e):this._wrapPoint(a,e)}_wrapMultipoint(a,e){const t=a.points,s=[];let i=0,r=0;for(const[n,o]of t){if(s.push([n+i,o]),i=0,e===$.i9){const h=5*$.OC;n+r<h?(s.push([e,0]),i=-e):n+r>$.i9-h&&(s.push([-e,0]),i=e)}else n+r<-$.OC?(s.push([e,0]),i=-e):n+r>$.i9+$.OC&&(s.push([-e,0]),i=e);r+=n}a.points=s}_wrapPoint(a,e){const t=a.geometry;if(e===$.i9){const s=5*$.OC;t.x<s?a.geometry={points:[[t.x,t.y],[e,0]]}:t.x>$.i9-s&&(a.geometry={points:[[t.x,t.y],[-e,0]]})}else t.x<-$.OC?a.geometry={points:[[t.x,t.y],[e,0]]}:t.x>$.i9+$.OC&&(a.geometry={points:[[t.x,t.y],[-e,0]]})}_processGraphics(a,e,t){if(!e||!e.length||!this._meshFactory)return Promise.resolve(null);const s=we.from(e,this.uid,a.transform),i=this._meshFactory;return this._matcher.then(r=>i.analyzeGraphics(s,this.container.stage.resourceManager,r,null,null,t).then(()=>(this._attributeStore.sendUpdates(),this._processAnalyzedGraphics(a,s))))}_processAnalyzedGraphics(a,e){const t=this._meshFactory,s=e.getSize(),i=e.getCursor(),n=new tt._(a.key.id,{features:s,records:s,metrics:0},C.mD.DEFAULT,!1,!1),o=[];for(;i.next();){const y=i.readGraphic();y.insertAfter=-1===y.insertAfter?-1:this._displayIds.get(y.insertAfter),y.displayId=this._displayIds.get(y.attributes[this.uid]);const x=new me(y.displayId);x.insertAfter=y.insertAfter,o.push(x),t.writeGraphic(n,i,a.level,this.container.stage.resourceManager)}const m=n.serialize(a.tileInfoView.tileInfo.isWrappable);return 1!==m.length?new oe:oe.fromVertexData(m[0].message,o)}_abortProcessingGraphic(a){this._graphicIdToAbortController.get(a)?.abort()}_getNullSymbol(a){const e=a.geometry;return(0,c.l9)(e)?l.mW:(0,c.oU)(e)||(0,c.YX)(e)?l.kD:this.defaultPointSymbolEnabled?l.G:null}_flipUpdatingGraphics(){this._updatingGraphicsTimer&&clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=setTimeout(()=>{this._updatingGraphicsTimer=null,this.notifyChange("updating")},160),this.notifyChange("updating")}};(0,U._)([(0,L.Cb)()],ie.prototype,"_effectiveRenderer",null),(0,U._)([(0,L.Cb)({constructOnly:!0})],ie.prototype,"requestUpdateCallback",void 0),(0,U._)([(0,L.Cb)()],ie.prototype,"container",void 0),(0,U._)([(0,L.Cb)({constructOnly:!0})],ie.prototype,"graphics",void 0),(0,U._)([(0,L.Cb)()],ie.prototype,"renderer",void 0),(0,U._)([(0,L.Cb)()],ie.prototype,"updating",null),(0,U._)([(0,L.Cb)()],ie.prototype,"view",void 0),(0,U._)([(0,L.Cb)()],ie.prototype,"updateRequested",void 0),(0,U._)([(0,L.Cb)()],ie.prototype,"defaultPointSymbolEnabled",void 0),ie=(0,U._)([(0,N.j)("esri.views.2d.layers.support.GraphicsView2D")],ie);const Ct=ie},62192:(fe,se,g)=>{g.d(se,{aV:()=>_,S1:()=>d,os:()=>l,st:()=>u,yR:()=>O});var c,z=g(26584),U=g(8314),Y=g(63290),E=g(50011),J=g(43149),X=g(95778),ee=g(15312),q=g(68598),I=g(64902),Q=g(17626),L=g(58817),W=g(77712),Z=(g(90912),g(76898)),H=g(99433),k=g(86971);let T=c=class extends q.Z{writeLevels(D,S,M){for(const A in D)return void(S.stops=this.levels[A])}clone(){return new c({axis:this.axis,field:this.field,valueExpression:this.valueExpression,valueExpressionTitle:this.valueExpressionTitle,maxDataValue:this.maxDataValue,maxSize:(0,k.iY)(this.maxSize)?this.maxSize.clone():this.maxSize,minDataValue:this.minDataValue,minSize:(0,k.iY)(this.minSize)?this.minSize.clone():this.minSize,normalizationField:this.normalizationField,stops:this.stops?.map(D=>D.clone()),target:this.target,useSymbolValue:this.useSymbolValue,valueRepresentation:this.valueRepresentation,valueUnit:this.valueUnit,legendOptions:this.legendOptions?.clone(),levels:(0,L.d9)(this.levels)})}};(0,Q._)([(0,W.Cb)()],T.prototype,"levels",void 0),(0,Q._)([(0,H.c)("levels")],T.prototype,"writeLevels",null),T=c=(0,Q._)([(0,Z.j)("esri.views.2d.engine.LevelDependentSizeVariable")],T);const f=Y.Z.getLogger("esri.views.2d.layers.support.clusterUtils");U.Z.add("esri-cluster-arcade-enabled",!0);const p=(0,U.Z)("esri-cluster-arcade-enabled"),d=(D,S,M,A,V)=>{const B=S.clone();if(!O(B))return B;if(B.authoringInfo||(B.authoringInfo=new ee.Z),B.authoringInfo.isAutoGenerated=!0,"visualVariables"in B){const j=(B.visualVariables||[]).filter(G=>"$view.scale"!==G.valueExpression),he=l(j);j.forEach(G=>{"rotation"===G.type?G.field?G.field=R(D,G.field,"avg_angle","number"):G.valueExpression&&(G.field=P(D,G.valueExpression,"avg_angle","number"),G.valueExpression=null):G.normalizationField?(G.field=R(D,G.field,"avg_norm","number",G.normalizationField),G.normalizationField=null):G.field?G.field=R(D,G.field,"avg","number"):G.valueExpression&&(G.field=P(D,G.valueExpression,"avg","number"),G.valueExpression=null)}),null==he&&!C(j)&&V&&(j.push(_(M,A)),B.dynamicClusterSize=!0),B.visualVariables=j}switch(B.type){case"simple":break;case"pie-chart":for(const j of B.attributes)j.field?j.field=R(D,j.field,"sum","number"):j.valueExpression&&(j.field=P(D,j.valueExpression,"sum","number"),j.valueExpression=null);break;case"unique-value":B.field?B.field=R(D,B.field,"mode","string"):B.valueExpression&&(B.field=P(D,B.valueExpression,"mode","string"),B.valueExpression=null);break;case"class-breaks":B.normalizationField?(B.field=R(D,B.field,"avg_norm","number",B.normalizationField),B.normalizationField=null):B.field?B.field=R(D,B.field,"avg","number"):B.valueExpression&&(B.field=P(D,B.valueExpression,"avg","number"),B.valueExpression=null)}return B},l=D=>{for(const S of D)if("size"===S.type)return S;return null};function u(D,S,M){const A=D.clone();let V=!1;if("visualVariables"in A){const B=(A.visualVariables||[]).filter(j=>"$view.scale"!==j.valueExpression);null==l(B)&&(A.visualVariables||(A.visualVariables=[]),A.visualVariables.push(_(S,M)),A.dynamicClusterSize=!0,V=!0)}return{renderer:A,didInject:V}}const C=D=>{for(const S of D)if("cluster_count"===S.field)return!0;return!1},_=(D,S)=>{const M=[new I.Z({value:0,size:0}),new I.Z({value:1})];if(null==S)return new q.Z({field:"cluster_count",stops:[...M,new I.Z({value:2,size:0})]});const A=Object.keys(S).reduce((V,B)=>({...V,[B]:[...M,new I.Z({value:Math.max(2,S[B].minValue),size:D.clusterMinSize}),new I.Z({value:Math.max(3,S[B].maxValue),size:D.clusterMaxSize})]}),{});return new T({field:"cluster_count",levels:A})},O=D=>{const S=M=>f.error(new z.Z("Unsupported-renderer",M,{renderer:D}));if(!D)return!1;switch(D.type){case"unique-value":if(D.field2||D.field3)return S("FeatureReductionCluster does not support multi-field UniqueValueRenderers"),!1;break;case"class-breaks":if(D.normalizationField){const M=D.normalizationType;if("field"!==M)return S(`FeatureReductionCluster does not support a normalizationType of ${M}`),!1}break;case"simple":case"pie-chart":break;default:return S(`FeatureReductionCluster does not support renderers of type ${D.type}`),!1}if(!p){if("valueExpression"in D&&D.valueExpression)return S("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"),!1;if(("visualVariables"in D&&D.visualVariables||[]).some(M=>!(!("valueExpression"in M)||!M.valueExpression)))return S("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"),!1}return!0};function P(D,S,M,A){const V=(0,E.F)(S),B="mode"===M?`cluster_type_${V}`:"sum"===M?`cluster_sum_${V}`:`cluster_avg_${V}`;return D.some(j=>j.name===B)||D.push(new J.Z({name:B,isAutoGenerated:!0,onStatisticExpression:new X.Z({expression:S,returnType:A}),statisticType:M})),B}function R(D,S,M,A,V){if("cluster_count"===S||D.some(j=>j.name===S))return S;const B=function K(D,S,M){switch(D){case"sum":return`cluster_sum_${S}`;case"avg":case"avg_angle":return`cluster_avg_${S}`;case"mode":return`cluster_type_${S}`;case"avg_norm":{const A=M,V="field",B=S.toLowerCase()+",norm:"+V+","+A.toLowerCase();return"cluster_avg_"+(0,E.F)(B)}}}(M,S,V);return D.some(j=>j.name===B)||D.push(new J.Z("avg_norm"===M?{name:B,isAutoGenerated:!0,onStatisticExpression:new X.Z({expression:`$feature.${S} / $feature.${V}`,returnType:A}),statisticType:"avg"}:{name:B,isAutoGenerated:!0,onStatisticField:S,statisticType:M})),B}}}]);