"use strict";(self.webpackChunkCRIS=self.webpackChunkCRIS||[]).push([[2041],{550:(U,A,m)=>{function y(){return[1,0,0,0,1,0,0,0,1]}function I(g,r,_,f,d,S,s,u,a){return[g,r,_,f,d,S,s,u,a]}function R(g,r){return new Float64Array(g,r,9)}m.d(A,{a:()=>y,c:()=>R,f:()=>I}),Object.freeze(Object.defineProperty({__proto__:null,clone:function v(g){return[g[0],g[1],g[2],g[3],g[4],g[5],g[6],g[7],g[8]]},create:y,createView:R,fromValues:I},Symbol.toStringTag,{value:"Module"}))},43703:(U,A,m)=>{function y(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}function v(r){return[r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8],r[9],r[10],r[11],r[12],r[13],r[14],r[15]]}function R(r,_){return new Float64Array(r,_,16)}m.d(A,{I:()=>Y,a:()=>y,b:()=>v,c:()=>R});const Y=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];Object.freeze(Object.defineProperty({__proto__:null,IDENTITY:Y,clone:v,create:y,createView:R,fromValues:function I(r,_,f,d,S,s,u,a,p,P,E,D,x,O,b,T){return[r,_,f,d,S,s,u,a,p,P,E,D,x,O,b,T]}},Symbol.toStringTag,{value:"Module"}))},78451:(U,A,m)=>{function y(){return[0,0,0,1]}function v(r){return[r[0],r[1],r[2],r[3]]}function R(r,_){return new Float64Array(r,_,4)}m.d(A,{I:()=>Y,a:()=>y,b:()=>v,c:()=>R});const Y=[0,0,0,1];Object.freeze(Object.defineProperty({__proto__:null,IDENTITY:Y,clone:v,create:y,createView:R,fromValues:function I(r,_,f,d){return[r,_,f,d]}},Symbol.toStringTag,{value:"Module"}))},79800:(U,A,m)=>{m.d(A,{a:()=>Y,b:()=>R,c:()=>v,d:()=>_,e:()=>g,n:()=>f,s:()=>r,t:()=>I});var y=m(96286);function v(s,u,a){I(s.typedBuffer,u.typedBuffer,a,s.typedBufferStride,u.typedBufferStride)}function I(s,u,a,p=3,P=p){if(s.length/p!==Math.ceil(u.length/P))return y.c.error("source and destination buffers need to have the same number of elements"),s;const E=s.length/p,D=a[0],x=a[1],O=a[2],b=a[4],T=a[5],w=a[6],C=a[8],l=a[9],t=a[10],e=a[12],n=a[13],i=a[14];let o=0,h=0;for(let c=0;c<E;c++){const M=u[o],X=u[o+1],B=u[o+2];s[h]=D*M+b*X+C*B+e,s[h+1]=x*M+T*X+l*B+n,s[h+2]=O*M+w*X+t*B+i,o+=P,h+=p}return s}function R(s,u,a){Y(s.typedBuffer,u.typedBuffer,a,s.typedBufferStride,u.typedBufferStride)}function Y(s,u,a,p=3,P=p){if(s.length/p!==Math.ceil(u.length/P))return void y.c.error("source and destination buffers need to have the same number of elements");const E=s.length/p,D=a[0],x=a[1],O=a[2],b=a[3],T=a[4],w=a[5],C=a[6],l=a[7],t=a[8];let e=0,n=0;for(let i=0;i<E;i++){const o=u[e],h=u[e+1],c=u[e+2];s[n]=D*o+b*h+C*c,s[n+1]=x*o+T*h+l*c,s[n+2]=O*o+w*h+t*c,e+=P,n+=p}}function g(s,u,a){r(s.typedBuffer,u,a,s.typedBufferStride)}function r(s,u,a,p=3){const P=Math.min(s.length/p,u.count),E=u.typedBuffer,D=u.typedBufferStride;let x=0,O=0;for(let b=0;b<P;b++)s[O]=a*E[x],s[O+1]=a*E[x+1],s[O+2]=a*E[x+2],x+=D,O+=p}function _(s,u){f(s.typedBuffer,u.typedBuffer,s.typedBufferStride,u.typedBufferStride)}function f(s,u,a=3,p=a){const P=Math.min(s.length/a,u.length/p);let E=0,D=0;for(let x=0;x<P;x++){const O=u[E],b=u[E+1],T=u[E+2],w=O*O+b*b+T*T;if(w>0){const C=1/Math.sqrt(w);s[D]=C*O,s[D+1]=C*b,s[D+2]=C*T}E+=p,D+=a}}Object.freeze(Object.defineProperty({__proto__:null,normalize:f,normalizeView:_,scale:r,scaleView:g,shiftRight:function d(s,u,a){const p=Math.min(s.count,u.count),P=s.typedBuffer,E=s.typedBufferStride,D=u.typedBuffer,x=u.typedBufferStride;let O=0,b=0;for(let T=0;T<p;T++)P[b]=D[O]>>a,P[b+1]=D[O+1]>>a,P[b+2]=D[O+2]>>a,O+=x,b+=E},transformMat3:Y,transformMat3View:R,transformMat4:I,transformMat4View:v},Symbol.toStringTag,{value:"Module"}))},36592:(U,A,m)=>{m.d(A,{Q:()=>R});var y=m(85931),v=m(77029),I=m(14259);class R{constructor(t=9,e){this._compareMinX=_,this._compareMinY=f,this._toBBox=n=>n,this._maxEntries=Math.max(4,t||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),e&&("function"==typeof e?this._toBBox=e:this._initFormat(e)),this.clear()}destroy(){this.clear(),E.prune(),D.prune(),x.prune(),O.prune()}all(t){this._all(this._data,t)}search(t,e){let n=this._data;const i=this._toBBox;if(p(t,n))for(E.clear();n;){for(let o=0,h=n.children.length;o<h;o++){const c=n.children[o],M=n.leaf?i(c):c;p(t,M)&&(n.leaf?e(c):a(t,M)?this._all(c,e):E.push(c))}n=E.pop()}}collides(t){let e=this._data;const n=this._toBBox;if(!p(t,e))return!1;for(E.clear();e;){for(let i=0,o=e.children.length;i<o;i++){const h=e.children[i],c=e.leaf?n(h):h;if(p(t,c)){if(e.leaf||a(t,c))return!0;E.push(h)}}e=E.pop()}return!1}load(t){if(!t.length)return this;if(t.length<this._minEntries){for(let n=0,i=t.length;n<i;n++)this.insert(t[n]);return this}let e=this._build(t.slice(0,t.length),0,t.length-1,0);if(this._data.children.length)if(this._data.height===e.height)this._splitRoot(this._data,e);else{if(this._data.height<e.height){const n=this._data;this._data=e,e=n}this._insert(e,this._data.height-e.height-1,!0)}else this._data=e;return this}insert(t){return t&&this._insert(t,this._data.height-1),this}clear(){return this._data=new w([]),this}remove(t){if(!t)return this;let e,n=this._data,i=null,o=0,h=!1;const c=this._toBBox(t);for(x.clear(),O.clear();n||x.length>0;){if(n||(n=x.pop(),i=x.data[x.length-1],o=O.pop()??0,h=!0),n.leaf&&(e=(0,y.cq)(n.children,t,n.children.length,n.indexHint),-1!==e))return n.children.splice(e,1),x.push(n),this._condense(x),this;h||n.leaf||!a(n,c)?i?(o++,n=i.children[o],h=!1):n=null:(x.push(n),O.push(o),o=0,i=n,n=n.children[0])}return this}toJSON(){return this._data}fromJSON(t){return this._data=t,this}_all(t,e){let n=t;for(D.clear();n;){if(!0===n.leaf)for(const i of n.children)e(i);else D.pushArray(n.children);n=D.pop()??null}}_build(t,e,n,i){const o=n-e+1;let h=this._maxEntries;if(o<=h){const B=new w(t.slice(e,n+1));return Y(B,this._toBBox),B}i||(i=Math.ceil(Math.log(o)/Math.log(h)),h=Math.ceil(o/h**(i-1)));const c=new C([]);c.height=i;const M=Math.ceil(o/h),X=M*Math.ceil(Math.sqrt(h));P(t,e,n,X,this._compareMinX);for(let B=e;B<=n;B+=X){const j=Math.min(B+X-1,n);P(t,B,j,M,this._compareMinY);for(let L=B;L<=j;L+=M){const K=Math.min(L+M-1,j);c.children.push(this._build(t,L,K,i-1))}}return Y(c,this._toBBox),c}_chooseSubtree(t,e,n,i){for(;i.push(e),!0!==e.leaf&&i.length-1!==n;){let o,h=1/0,c=1/0;for(let M=0,X=e.children.length;M<X;M++){const B=e.children[M],j=d(B),L=s(t,B)-j;L<c?(c=L,h=j<h?j:h,o=B):L===c&&j<h&&(h=j,o=B)}e=o||e.children[0]}return e}_insert(t,e,n){const o=n?t:(0,this._toBBox)(t);x.clear();const h=this._chooseSubtree(o,this._data,e,x);for(h.children.push(t),r(h,o);e>=0&&x.data[e].children.length>this._maxEntries;)this._split(x,e),e--;this._adjustParentBBoxes(o,x,e)}_split(t,e){const n=t.data[e],i=n.children.length,o=this._minEntries;this._chooseSplitAxis(n,o,i);const h=this._chooseSplitIndex(n,o,i);if(!h)return void console.log("  Error: assertion failed at PooledRBush._split: no valid split index");const c=n.children.splice(h,n.children.length-h),M=n.leaf?new w(c):new C(c);M.height=n.height,Y(n,this._toBBox),Y(M,this._toBBox),e?t.data[e-1].children.push(M):this._splitRoot(n,M)}_splitRoot(t,e){this._data=new C([t,e]),this._data.height=t.height+1,Y(this._data,this._toBBox)}_chooseSplitIndex(t,e,n){let i,o,h;i=o=1/0;for(let c=e;c<=n-e;c++){const M=g(t,0,c,this._toBBox),X=g(t,c,n,this._toBBox),B=u(M,X),j=d(M)+d(X);B<i?(i=B,h=c,o=j<o?j:o):B===i&&j<o&&(o=j,h=c)}return h}_chooseSplitAxis(t,e,n){const i=t.leaf?this._compareMinX:_,o=t.leaf?this._compareMinY:f;this._allDistMargin(t,e,n,i)<this._allDistMargin(t,e,n,o)&&t.children.sort(i)}_allDistMargin(t,e,n,i){t.children.sort(i);const o=this._toBBox,h=g(t,0,e,o),c=g(t,n-e,n,o);let M=S(h)+S(c);for(let X=e;X<n-e;X++){const B=t.children[X];r(h,t.leaf?o(B):B),M+=S(h)}for(let X=n-e-1;X>=e;X--){const B=t.children[X];r(c,t.leaf?o(B):B),M+=S(c)}return M}_adjustParentBBoxes(t,e,n){for(let i=n;i>=0;i--)r(e.data[i],t)}_condense(t){for(let e=t.length-1;e>=0;e--){const n=t.data[e];if(0===n.children.length)if(e>0){const i=t.data[e-1],o=i.children;o.splice((0,y.cq)(o,n,o.length,i.indexHint),1)}else this.clear();else Y(n,this._toBBox)}}_initFormat(t){const e=["return a"," - b",";"];this._compareMinX=new Function("a","b",e.join(t[0])),this._compareMinY=new Function("a","b",e.join(t[1])),this._toBBox=new Function("a","return {minX: a"+t[0]+", minY: a"+t[1]+", maxX: a"+t[2]+", maxY: a"+t[3]+"};")}}function Y(l,t){g(l,0,l.children.length,t,l)}function g(l,t,e,n,i){i||(i=new w([])),i.minX=1/0,i.minY=1/0,i.maxX=-1/0,i.maxY=-1/0;for(let o,h=t;h<e;h++)o=l.children[h],r(i,l.leaf?n(o):o);return i}function r(l,t){l.minX=Math.min(l.minX,t.minX),l.minY=Math.min(l.minY,t.minY),l.maxX=Math.max(l.maxX,t.maxX),l.maxY=Math.max(l.maxY,t.maxY)}function _(l,t){return l.minX-t.minX}function f(l,t){return l.minY-t.minY}function d(l){return(l.maxX-l.minX)*(l.maxY-l.minY)}function S(l){return l.maxX-l.minX+(l.maxY-l.minY)}function s(l,t){return(Math.max(t.maxX,l.maxX)-Math.min(t.minX,l.minX))*(Math.max(t.maxY,l.maxY)-Math.min(t.minY,l.minY))}function u(l,t){const e=Math.max(l.minX,t.minX),n=Math.max(l.minY,t.minY),i=Math.min(l.maxX,t.maxX),o=Math.min(l.maxY,t.maxY);return Math.max(0,i-e)*Math.max(0,o-n)}function a(l,t){return l.minX<=t.minX&&l.minY<=t.minY&&t.maxX<=l.maxX&&t.maxY<=l.maxY}function p(l,t){return t.minX<=l.maxX&&t.minY<=l.maxY&&t.maxX>=l.minX&&t.maxY>=l.minY}function P(l,t,e,n,i){const o=[t,e];for(;o.length;){const h=o.pop(),c=o.pop();if(h-c<=n)continue;const M=c+Math.ceil((h-c)/n/2)*n;(0,I.q)(l,M,c,h,i),o.push(c,M,M,h)}}const E=new v.Z,D=new v.Z,x=new v.Z,O=new v.Z({deallocator:void 0});class b{constructor(){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0}}class T extends b{constructor(){super(...arguments),this.height=1,this.indexHint=new y.SO}}class w extends T{constructor(t){super(),this.children=t,this.leaf=!0}}class C extends T{constructor(t){super(),this.children=t,this.leaf=!1}}},80130:(U,A,m)=>{m.d(A,{Z:()=>u});var y=m(17626),v=m(79608),I=m(86810),R=m(77712),_=(m(90912),m(85931),m(8314),m(55342)),f=m(76898),d=m(28093),S=m(72642);let s=class extends((0,v.J)(I.wq)){constructor(a){super(a),this.type="georeferenced-relative",this.isRelative=!0,this.isGeoreferenced=!0,this.origin=(0,d.c)()}getOriginPoint(a){const[p,P,E]=this.origin;return new S.Z({x:p,y:P,z:E,spatialReference:a})}setOriginFromPoint({x:a,y:p,z:P}){this.origin=(0,d.f)(a,p,P??0)}};(0,y._)([(0,_.J)({georeferencedRelative:"georeferenced-relative"},{readOnly:!0})],s.prototype,"type",void 0),(0,y._)([(0,R.Cb)({type:[Number],nonNullable:!0,json:{write:!0}})],s.prototype,"origin",void 0),s=(0,y._)([(0,f.j)("esri.geometry.support.MeshGeoreferencedRelativeVertexSpace")],s);const u=s},96286:(U,A,m)=>{m.d(A,{c:()=>v});const v=m(63290).Z.getLogger("esri.views.3d.support.buffer.math")},28149:(U,A,m)=>{m.r(A),m.d(A,{default:()=>Y});var y=m(15861),v=m(8314),I=m(36592),R=m(60853);class Y{createIndex(_,f){var d=this;return(0,y.Z)(function*(){const S=new Array;if(!_.vertexAttributes?.position)return new I.Q;const s=d._createMeshData(_),u=null!=f?yield f.invoke("createIndexThread",s,{transferList:S}):d.createIndexThread(s).result;return d._createPooledRBush().fromJSON(u)})()}createIndexThread(_){const f=new Float64Array(_.position),d=this._createPooledRBush();return _.components?this._createIndexComponentsThread(d,f,_.components.map(S=>new Uint32Array(S))):this._createIndexAllThread(d,f)}_createIndexAllThread(_,f){const d=new Array(f.length/9);let S=0;for(let s=0;s<f.length;s+=9)d[S++]=g(f,s,s+3,s+6);return _.load(d),{result:_.toJSON()}}_createIndexComponentsThread(_,f,d){let S=0;for(const a of d)S+=a.length/3;const s=new Array(S);let u=0;for(const a of d)for(let p=0;p<a.length;p+=3)s[u++]=g(f,3*a[p],3*a[p+1],3*a[p+2]);return _.load(s),{result:_.toJSON()}}_createMeshData(_){const f=(_.vertexSpace.isRelative?(0,R.georeferenceApplyTransform)({position:_.vertexAttributes.position,normal:null,tangent:null},_.vertexSpace,_.transform,_.spatialReference).position:_.vertexAttributes.position).buffer;return!_.components||_.components.some(d=>!d.faces)?{position:f}:{position:f,components:_.components.map(d=>d.faces)}}_createPooledRBush(){return new I.Q(9,(0,v.Z)("esri-csp-restrictions")?_=>_:[".minX",".minY",".maxX",".maxY"])}}function g(r,_,f,d){return{minX:Math.min(r[_],r[f],r[d]),maxX:Math.max(r[_],r[f],r[d]),minY:Math.min(r[_+1],r[f+1],r[d+1]),maxY:Math.max(r[_+1],r[f+1],r[d+1]),p0:[r[_],r[_+1],r[_+2]],p1:[r[f],r[f+1],r[f+2]],p2:[r[d],r[d+1],r[d+2]]}}}}]);